// THIS FILE IS AUTOMATICALLY GENERATED EACH BUILD!

#ifndef __constants_h
#define __constants_h

#ifdef DABES_IOS
#define FPS 60
#else
#define FPS 60
#endif

#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define DEFAULT_PPM 32

#define NUM_BOXES 100

#define MVMT_RUN_ACCEL 15
#define MVMT_AIR_ACCEL 2 * MVMT_RUN_ACCEL
#define MVMT_TURN_ACCEL 3 * MVMT_RUN_ACCEL
#define MVMT_FRICTION MVMT_RUN_ACCEL
#define MVMT_MAX_VELO 15
#define MVMT_JUMP_VELO_HI -8
#define MVMT_JUMP_VELO_LO -4

#define PHYS_DEFAULT_GRID_SIZE 2.0
#define FIXTURE_HISTORY_LENGTH 10


#endif
#ifndef __dbg_h__
#define __dbg_h__

#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, "DEBUG %s:%d: " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? "None" : strerror(errno))

#define log_err(M, ...) fprintf(stderr, "[ERROR] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr, "[WARN] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, "[INFO] (%s:%d) " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define check_mem(A) check((A), "Out of memory.")

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__); errno=0; goto error; }

#define debug_rect(a) \
    debug("(%f, %f), (%f, %f), (%f, %f), (%f, %f)", \
            a.tl.x, a.tl.y, a.tr.x, a.tr.y, a.bl.x, a.bl.y, a.br.x, a.br.y)


#endif
#ifndef __util_h
#define __util_h
#define sign(N) (N > 0) - (N < 0)

#ifndef MIN
#define MIN(A, B) (A < B ? A : B)
#endif
#ifndef MAX
#define MAX(A, B) (A > B ? A : B)
#endif

#define countfunc() \
  static int func_ctr = 0; \
  func_ctr++; \
  printf("%s called %d\n", __func__, func_ctr);

#define fequal(a,b) (fabs((a) - (b)) < FLT_EPSILON)
#define streq(A, B) (strcmp((const char *)A, (const char *)B) == 0)

#endif
#ifndef __prefix_h
#define __prefix_h

#include <math.h>
#include <float.h>

#if !defined(DABES_IOS) && !defined(DABES_MAC)
  #include <assert.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <lcthw/liblcthw.h>
  #include <SDL/SDL.h>
  #include <SDL/SDL_image.h>
  #include <SDL/SDL_opengl.h>
  #include <SDL/SDL_mixer.h>
  #include <SDL/SDL_ttf.h>
  #define DABES_SDL
#endif


extern char *bundlePath__;

#endif

#ifdef DABES_IOS
#define DABES_GLVERSION "gles"
#else
#define DABES_GLVERSION "gl"
#endif

#define shader_path(N) "shaders/" DABES_GLVERSION "/" N

#ifdef __GNUC__
#  define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_ ## x
#endif

#ifdef __GNUC__
#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_ ## x
#else
#  define UNUSED_FUNCTION(x) UNUSED_ ## x
#endif
#ifndef _object_h
#define _object_h

typedef struct {
    char *description;
    int (*init)(void *self);
    void (*describe)(void *self);
    void (*destroy)(void *self);
} Object;

int Object_init(void *self);
void Object_destroy(void *self);
void Object_describe(void *self);
void *Object_new(size_t size, Object proto, char *description);

#define NEW(T, N) Object_new(sizeof(T), T##Proto, N)
#define _(N) proto.N
#define m_(N, M, ...) N->M(N, ##__VA_ARGS__)

#endif
#ifndef __prefix_h
#define __prefix_h

#include <math.h>
#include <float.h>

#if !defined(DABES_IOS) && !defined(DABES_MAC)
  #include <assert.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <lcthw/liblcthw.h>
  #include <SDL/SDL.h>
  #include <SDL/SDL_image.h>
  #include <SDL/SDL_opengl.h>
  #include <SDL/SDL_mixer.h>
  #include <SDL/SDL_ttf.h>
  #define DABES_SDL
#endif


extern char *bundlePath__;

#endif

#ifdef DABES_IOS
#define DABES_GLVERSION "gles"
#else
#define DABES_GLVERSION "gl"
#endif

#define shader_path(N) "shaders/" DABES_GLVERSION "/" N

#ifdef __GNUC__
#  define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_ ## x
#endif

#ifdef __GNUC__
#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_ ## x
#else
#  define UNUSED_FUNCTION(x) UNUSED_ ## x
#endif
#ifndef __audio_h
#define __audio_h
#include <lcthw/list.h>
#if defined(DABES_IOS) || defined(DABES_MAC)
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#else
#include <al/al.h>
#include <al/alc.h>
#endif


typedef struct Audio {
    List *musics;
    List *active_sfx;
    ALCdevice *device;
    ALCcontext *context;
} Audio;

Audio *Audio_create();
int Audio_check();
void Audio_stream(Audio *audio);
void Audio_destroy(Audio *audio);

struct Music;
struct Music *Audio_gen_music(Audio *audio, int num_files, char *files[]);
void Audio_destroy_music(Audio *audio, struct Music *music);

struct Sfx;
struct Sfx *Audio_gen_sfx(Audio *audio, char *filename);
void Audio_destroy_sfx(Audio *audio, struct Sfx *sfx);

#endif
#ifndef __ogg_stream_h
#define __ogg_stream_h
#include <stdio.h>
#include <stdlib.h>

#if defined(DABES_IOS) || defined(DABES_MAC)
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#include <Ogg/ogg.h>
#include <Vorbis/codec.h>
#include <Vorbis/vorbisenc.h>
#include <Vorbis/vorbisfile.h>
#else
#include <al/al.h>
#include <al/alc.h>
#include <ogg/ogg.h>
#include <vorbis/codec.h>
#include <vorbis/vorbisenc.h>
#include <vorbis/vorbisfile.h>
#endif


typedef struct OggStream {
    char *filename;
    FILE *file;
    OggVorbis_File stream;
    vorbis_info *vorbis_info;
    vorbis_comment *vorbis_comment;

    int buf_count;
    ALuint buffers[2];
    ALuint source;
    ALenum format;

    int started;
    int should_loop;
    int eof;
    int ended;
} OggStream;

OggStream *OggStream_create(char *file, ALuint source);
OggStream *OggStream_clone(OggStream *ogg_stream);
void OggStream_destroy(OggStream *ogg_stream);
void OggStream_debug(OggStream *ogg_stream);
int OggStream_stop(OggStream *ogg_stream);
int OggStream_play(OggStream *ogg_stream);
int OggStream_playing(OggStream *ogg_stream);
int OggStream_update(OggStream *ogg_stream);
void OggStream_rewind(OggStream *ogg_stream);

#endif
#ifndef __audio_h
#define __audio_h
#include <lcthw/list.h>
#if defined(DABES_IOS) || defined(DABES_MAC)
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#else
#include <al/al.h>
#include <al/alc.h>
#endif


typedef struct Audio {
    List *musics;
    List *active_sfx;
    ALCdevice *device;
    ALCcontext *context;
} Audio;

Audio *Audio_create();
int Audio_check();
void Audio_stream(Audio *audio);
void Audio_destroy(Audio *audio);

struct Music;
struct Music *Audio_gen_music(Audio *audio, int num_files, char *files[]);
void Audio_destroy_music(Audio *audio, struct Music *music);

struct Sfx;
struct Sfx *Audio_gen_sfx(Audio *audio, char *filename);
void Audio_destroy_sfx(Audio *audio, struct Sfx *sfx);

#endif
#ifndef __music_h
#define __music_h
#include <lcthw/list.h>
#include <OpenAL/al.h>

typedef struct Music {
    double volume;
    List *ogg_streams;
    int playing;
    int ended;
    ALuint source;
    OggStream *active_stream;

    int num_files;
    char *ogg_files[];
} Music;

Music *Music_load(int num_files, char *ogg_files[]);
void Music_destroy(Music *music);
void Music_play(Music *music);
void Music_update(Music *music);
void Music_pause(Music *music);
void Music_end(Music *music);
void Music_set_volume(Music *music, double volume);

#endif
#ifndef __binding_macros_h
#define __binding_macros_h

// Defining Types
#define Scripting_userdata_for(STYPE) \
struct STYPE ## _userdata { \
    lua_State *L; \
    STYPE *p; \
}

#define Scripting_caster_for(STYPE, FNAME) \
static inline STYPE *FNAME(lua_State *L, int narg) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) \
        luaL_checkudata(L, narg, luab_ ## STYPE ## _metatable); \
    check(ud != NULL, "Object at %d is not type %s", narg, #STYPE); \
    check(ud->p != NULL, "Userdata has no %s object", #STYPE); \
    return ud->p; \
error: \
    return NULL; \
}

#define Scripting_null_closer(STYPE) \
static inline int luab_ ## STYPE ## _close(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    ud->p = NULL; \
    return 0; \
}

#define Scripting_destroy_closer(STYPE) \
static inline int luab_ ## STYPE ## _close(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    if (ud->p) { \
        STYPE ## _destroy(ud->p); \
    } \
    ud->p = NULL; \
    return 0; \
}

// Property accessor generation, basic types
#define Scripting_num_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    check(lua_isnumber(L, 2), \
            "Please provide a number to set "#STYPE"->"#SPROP); \
    lua_Number num = lua_tonumber(L, 2); \
    STYPE *s = ud->p; \
    s->SPROP = num; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_num_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_Number ret = s->SPROP; \
    lua_pushnumber(L, ret); \
    return 1; \
}

#define Scripting_bool_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    check(lua_isboolean(L, 2), \
            "Please provide a boolean to set "#STYPE"->"#SPROP); \
    int num = lua_toboolean(L, 2); \
    STYPE *s = ud->p; \
    s->SPROP = num; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_bool_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    int ret = s->SPROP; \
    lua_pushboolean(L, ret); \
    return 1; \
}

// Property synthesis, complex types
#define Scripting_VPoint_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_newtable(L); \
    lua_pushinteger(L, 1); \
    lua_pushnumber(L, s->SPROP.x); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 2); \
    lua_pushnumber(L, s->SPROP.y); \
    lua_settable(L, -3); \
    return 1; \
}

#define Scripting_VPoint_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    check(luaL_unpack_exact(L, 2), \
            "Please provide 2 numbers to set " #STYPE "->" #SPROP ); \
    VPoint point = {lua_tonumber(L, -2), lua_tonumber(L, -1)}; \
    lua_pop(L, 2); \
    s->SPROP = point; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_VVector4_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_newtable(L); \
    lua_pushinteger(L, 1); \
    lua_pushnumber(L, s->SPROP.raw[0]); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 2); \
    lua_pushnumber(L, s->SPROP.raw[1]); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 3); \
    lua_pushnumber(L, s->SPROP.raw[2]); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 4); \
    lua_pushnumber(L, s->SPROP.raw[3]); \
    lua_settable(L, -3); \
    return 1; \
}

#define Scripting_VVector4_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    check(luaL_unpack_exact(L, 4), \
            "Please provide 4 numbers to set " #STYPE "->" #SPROP ); \
    VVector4 vertex = {.raw = {lua_tonumber(L, -4), lua_tonumber(L, -3), \
        lua_tonumber(L, -2), lua_tonumber(L, -1)}}; \
    lua_pop(L, 4); \
    s->SPROP = vertex; \
    return 1; \
error: \
    return 0; \
}

#endif
#ifndef __vpoint_h
#define __vpoint_h
#include <chipmunk/chipmunk.h>

typedef enum {
  VPointRelWithin = 0,
  VPointRelXLess = 1 << 0,
  VPointRelXMore = 1 << 1,
  VPointRelYLess = 1 << 2,
  VPointRelYMore = 1 << 3
} VPointRel;

typedef struct VPoint {
    float x;
    float y;
} VPoint;

static const VPoint VPointZero = {0,0};

VPoint VPoint_add(VPoint a, VPoint b);
VPoint VPoint_subtract(VPoint a, VPoint b);
VPoint VPoint_multiply(VPoint a, VPoint b);
double VPoint_angle(VPoint a, VPoint b);
VPoint VPoint_scale(VPoint a, double b);
double VPoint_dot(VPoint a, VPoint b);
double VPoint_cross(VPoint a, VPoint b);
VPoint VPoint_mid(VPoint a, VPoint b);
VPoint VPoint_rotate(VPoint point, VPoint pivot, double angle_in_rads);
VPoint VPoint_perp(VPoint a);
VPoint VPoint_normalize(VPoint a);
double VPoint_magnitude(VPoint a);
VPointRel VPoint_rel(VPoint a, VPoint b);

static inline void VPoint_debug(VPoint point, char *msg) {
    debug("<%f, %f> %s", point.x, point.y, msg);
}

#endif
#ifndef __scripting_h
#define __scripting_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *SCRIPTING_CL_ENTITY_CONFIG;
extern const char *SCRIPTING_CL_PARALLAX;
extern const char *SCRIPTING_CL_PARALLAX_LAYER;
extern const char *SCRIPTING_ENGINE_REGISTRY_KEY;

typedef void (*Scripting_error_cb)(const char *error);

typedef struct Scripting {
    lua_State *L;
    Scripting_error_cb error_callback;
    Scripting_error_cb panic_callback;
} Scripting;

struct Engine;
Scripting *Scripting_create(struct Engine *engine, const char *boot_script);
void Scripting_destroy(Scripting *scripting);
void Scripting_register_engine(Scripting *scripting, struct Engine *engine);
void Scripting_boot(Scripting *scripting);
void Scripting_update_paths(Scripting *scripting, struct Engine *engine);

int Scripting_call_hook(Scripting *scripting, void *bound, const char *fname);
void *Scripting_ud_return_hook(Scripting *scripting, void *bound,
        const char *fname);

void luaL_register_ud(lua_State *L, int ud_idx, void **ud_prop, void *val);
int luaL_lookup_ud(lua_State *L, void *val);
int luaL_lookup_instance(lua_State *L, void *val);
void luaL_createweakweaktable(lua_State *L);
void luaL_createweakstrongtable(lua_State *L);
void luaL_createstrongweaktable(lua_State *L);
int luab_register_instance(lua_State *L);
struct Engine *luaL_get_engine(lua_State *L);
int luaL_unpack_exact (lua_State *L, int count);

VPoint luaL_tovpoint(lua_State *L, int idx);
int luaL_pushvpoint(lua_State *L, VPoint point);

#define Scripting_bail(L, MSG) { \
    fprintf(stderr, "%s: %s\n", MSG, lua_tostring(L, -1)); \
    return 0; \
}

#endif
#ifndef __music_bindings_h
#define __music_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Music_lib;
extern const char *luab_Music_metatable;

typedef Scripting_userdata_for(Music) Music_userdata;

Scripting_caster_for(Music, luaL_tomusic);

int luaopen_dabes_music(lua_State *L);

#endif
#ifndef __sfx_h
#define __sfx_h
#include <OpenAL/al.h>

typedef struct Sfx {
    double volume;
    int playing;
    int ended;
    ALuint source;

    OggStream *ogg_stream;
} Sfx;

Sfx *Sfx_load(char *filename);
void Sfx_destroy(Sfx *sfx);
void Sfx_play(Sfx *sfx);
void Sfx_update(Sfx *sfx);
void Sfx_set_volume(Sfx *sfx, double volume);

#endif
#ifndef __sfx_bindings
#define __sfx_bindings
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Sfx_lib;
extern const char *luab_Sfx_metatable;

typedef Scripting_userdata_for(Sfx) Sfx_userdata;

Scripting_caster_for(Sfx, luaL_tosfx);

int luaopen_dabes_sfx(lua_State *L);

#endif
#ifndef __base64_h
#define __base64_h

int base64_encode(unsigned char *source, size_t sourcelen, char *target, size_t targetlen);
size_t base64_decode(char *source, unsigned char **target, size_t targetlen);
#endif
#ifndef __easer_h
#define __easer_h

typedef float (*Easer_curve)(float progress);

struct Engine;
typedef struct Easer {
    int length_ms;
    int accumulator;
    int finished;
    float time_scale;
    float value;
    Easer_curve curve;
} Easer;

float Easer_curve_linear(float progress);

Easer *Easer_create(int length_ms, Easer_curve curve);
void Easer_destroy(Easer *easer);
void Easer_update(Easer *easer, struct Engine *engine, unsigned long delta_t);

#endif
#ifndef __easer_bindings_h
#define __easer_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Easer_lib;
extern const char *luab_Easer_metatable;
typedef Scripting_userdata_for(Easer) Easer_userdata;
Scripting_caster_for(Easer, luaL_toeaser);

int luaopen_dabes_easer(lua_State *L);

#endif
#ifndef __controller_h
#define __controller_h

typedef enum {
    CONTROLLER_DPAD_NONE = 0,
    CONTROLLER_DPAD_UP = 1<<0,
    CONTROLLER_DPAD_RIGHT = 1<<1,
    CONTROLLER_DPAD_DOWN = 1<<2,
    CONTROLLER_DPAD_LEFT = 1<<3
} Controller_dpad_direction;

typedef struct Controller {
    Controller_dpad_direction dpad;
    int jump;
} Controller;

Controller *Controller_create();
void Controller_destroy(Controller *controller);
void Controller_reset(Controller *controller);

extern Object ControllerProto;
#endif
#ifndef __input_h
#define __input_h

typedef struct Input {
    Controller *controllers[4];
    int game_quit;
    int debug_scene_draw_grid;
    int cam_reset;
    int cam_zoom;
    int cam_rotate;
    VPoint cam_focal_pan;
    VPoint cam_translate_pan;
    int cam_debug;
    int phys_render;
  
} Input;

Input *Input_create();
void Input_destroy(Input *input);
void Input_poll(Input *input);
void Input_touch(Input *input, Input *touch_input);
void Input_reset(Input *input);

#endif
#ifndef __vmatrix_h
#define __vmatrix_h

#ifdef DABES_IOS
#include <GLKit/GLKMath.h>
#include <OpenGLES/ES2/gl.h>
#include <QuartzCore/CoreAnimation.h>
#endif
#ifdef DABES_MAC
#include <OpenGL/OpenGL.h>
#include <GLKit/GLKMath.h>
#include <QuartzCore/CATransform3D.h>
#endif

typedef union VVector3 {
  struct { float x, y, z; };
  struct { float r, g, b; };
  struct { float s, t, p; };
  float v[3];
} VVector3;

VVector3 VVector3_normalize(VVector3 vector);
float VVector3_length(VVector3 vector);

typedef union VVector4 {
  struct {
    float x;
    float y;
    float z;
    float w;
  } packed;
  struct {
    float r;
    float g;
    float b;
    float a;
  } rgba;
  float raw[4];
} VVector4;

typedef union VMatrix {
    struct {
      float m11, m12, m13, m14;
      float m21, m22, m23, m24;
      float m31, m32, m33, m34;
      float m41, m42, m43, m44;
    } gfx;
    float gl[16];
    VVector4 v[4];
#if defined(DABES_IOS) || defined(DABES_MAC)
    CATransform3D ca;
#endif
#ifdef DABES_IOS
    GLKMatrix4 glk;
#endif
} VMatrix;

extern const VMatrix VMatrixIdentity;

VMatrix VMatrix_multiply(VMatrix a, VMatrix b);
VMatrix VMatrix_transpose(VMatrix m);
VMatrix VMatrix_scale(VMatrix matrix, double x, double y, double z);
VMatrix VMatrix_make_rotation(float radians, float x, float y, float z);
VMatrix VMatrix_rotate(VMatrix matrix, double rot_degs, double x, double y,
                       double z);
VMatrix VMatrix_translate(VMatrix matrix, double tx, double ty, double tz);
VMatrix VMatrix_make_ortho(float left, float right, float top,
                           float bottom, float near, float far);
int VMatrix_is_equal(VMatrix a, VMatrix b);

#endif
#ifndef __vrect_h
#define __vrect_h

typedef struct VProjection {
    double min;
    double max;
} VProjection;

int VProjection_does_overlap(VProjection a, VProjection b);
double VProjection_get_overlap(VProjection a, VProjection b);

typedef struct VRectInset {
  double top;
  double right;
  double bottom;
  double left;
} VRectInset;

typedef struct VRect {
    VPoint tl;
    VPoint tr;
    VPoint br;
    VPoint bl;
} VRect;

static const VRect VRectZero = {{0,0},{0,0},{0,0},{0,0}};

VRect VRect_from_xywh(double x, double y, double w, double h);
VRect VRect_inset(VRect rect, VRectInset inset);
VRect VRect_round_out(VRect rect);

VPoint VRect_center(VRect box);
float VRect_width(VRect rect);
float VRect_height(VRect rect);
VPoint VRect_vertex(VRect box, unsigned int index);
void VRect_set_vertex(VRect *box, unsigned int index, VPoint vertex);
VRect VRect_rotate(VRect box, VPoint pivot, double angle_in_rads);
VRect VRect_move(VRect box, VPoint move);
VRect VRect_scale(VRect box, double scale);

VProjection VRect_project_onto(VRect box, VPoint axis);
void VRect_find_axes(VRect box, VPoint *axes);
int VRect_collision(VRect a, VRect b, VPoint *mtv);
VPoint VRect_poc(VRect a, VRect b);
int VRect_contains_point(VRect box, VPoint point);
int VRect_contains_rect(VRect outer, VRect inner);
VRect VRect_bounding_box(VRect rect);
int VRect_is_equal(VRect *a, VRect *b);
VPoint VRect_cnormal_from_mtv(VRect normal_for, VRect against,
        VPoint mtv);

static inline void VRect_debug(VRect rect, char *msg) {
    int i = 0;
    debug("VRect: %s", msg);
    for (i = 0; i < 4; i++) {
        VPoint_debug(VRect_vertex(rect, i), NULL);
    }
    debug("---");
}

#ifdef DABES_SDL
VRect VRect_from_SDL_Rect(SDL_Rect rect);
#endif

VPointRel VPoint_rect_rel(VPoint point, VRect rect);

#endif
#ifndef __graphics_h
#define __graphics_h
#include <lcthw/hashmap.h>

#ifdef DABES_SDL
#include <SDL/SDL_ttf.h>
#endif

int Graphics_init_GL(int swidth, int sheight);

typedef struct GfxSize {
    double w;
    double h;
} GfxSize;

static const GfxSize GfxSizeZero = {0,0};
VRect VRect_fill_size(GfxSize source_size, GfxSize dest_size);

// GfxSize load_image_dimensions_from_image(char *filename);

typedef struct GfxTexture {
    const char *name;
    GfxSize size;
    GfxSize pot_size;
    GLuint gl_tex;
} GfxTexture;

GfxTexture *GfxTexture_from_data(unsigned char **data, int width, int height,
        GLenum source_format);
GfxTexture *GfxTexture_from_image(const char *image_name);
void GfxTexture_destroy(GfxTexture *texture);

enum {
    UNIFORM_DECAL_PROJECTION_MATRIX,
    UNIFORM_DECAL_HAS_TEXTURE,
    UNIFORM_DECAL_TEXTURE,
    UNIFORM_TILEMAP_PROJECTION_MATRIX,
    UNIFORM_TILEMAP_MODELVIEW_MATRIX,
    UNIFORM_TILEMAP_TILE_SIZE,
    UNIFORM_TILEMAP_SHEET_ROWS_COLS,
    UNIFORM_TILEMAP_SHEET_POT_SIZE,
    UNIFORM_TILEMAP_MAP_ROWS_COLS,
    UNIFORM_TILEMAP_ATLAS,
    UNIFORM_TILEMAP_TILESET,
    UNIFORM_PARALLAX_PROJECTION_MATRIX,
    UNIFORM_PARALLAX_MODELVIEW_MATRIX,
    UNIFORM_PARALLAX_TEXTURE,
    UNIFORM_PARALLAX_TEX_PORTION,
    UNIFORM_PARALLAX_REPEAT_SIZE,
    UNIFORM_PARALLAX_REPEATS,
    UNIFORM_PARALLAX_CAMERA_POS,
    UNIFORM_PARALLAX_FACTOR,
    UNIFORM_PARALLAX_TEX_SCALE,
    NUM_UNIFORMS
} UNIFORMS;

enum {
    ATTRIB_DECAL_VERTEX,
    ATTRIB_DECAL_COLOR,
    ATTRIB_DECAL_TEXTURE,
    ATTRIB_DECAL_MODELVIEW_MATRIX,
    ATTRIB_TILEMAP_VERTEX,
    ATTRIB_TILEMAP_TEXTURE,
    ATTRIB_PARALLAX_VERTEX,
    ATTRIB_PARALLAX_TEXTURE,
	NUM_ATTRIBUTES
} ATTRIBS;

enum {
  SAMPLER_TILEMAP_ATLAS,
  SAMPLER_TILEMAP_TILESET,
  NUM_SAMPLERS
} SAMPLERS;

extern GLint GfxShader_uniforms[NUM_UNIFORMS];
extern GLint GfxShader_attributes[NUM_ATTRIBUTES];
extern GLint GfxShader_samplers[NUM_SAMPLERS];

struct Graphics;
struct DrawBuffer;
typedef struct GfxShader {
    void (*set_up)(struct GfxShader *shader, struct Graphics *graphics);
    void (*tear_down)(struct GfxShader *shader, struct Graphics *graphics);
    GLuint gl_program;
    GLuint gl_vertex_array;
    struct DrawBuffer *draw_buffer;
} GfxShader;

void GfxShader_destroy(GfxShader *shader, struct Graphics *graphics);

///////////

typedef struct Graphics {
    struct Engine *engine;
  
    GfxSize screen_size;
    GLuint debug_text_texture;
    GfxShader *current_shader;
#ifdef DABES_SDL
    TTF_Font *debug_text_font;
#endif
    GLuint array_buffer;

    VMatrix projection_matrix;
    VMatrix modelview_matrix;

    Hashmap *textures;
    Hashmap *shaders;
    List *shader_list;
    Hashmap *sprites;

    int gl_vao_enabled;
    void (*gen_vao)(GLsizei n, GLuint *arrays);
    void (*bind_vao)(GLuint array);
    void (*del_vao)(GLsizei n, const GLuint *arrays);
} Graphics;

struct Engine;
Graphics *Graphics_create(struct Engine *engine);
void Graphics_destroy(Graphics *graphics);
  
void Graphics_stroke_poly(Graphics *graphics, int num_points, VPoint *points,
        VPoint center, GLfloat color[4], double line_width, double rotation);
void Graphics_stroke_rect(Graphics *graphics, VRect rect, GLfloat color[4],
        double line_width, double rotation);
void Graphics_draw_rect(Graphics *graphics, struct DrawBuffer *draw_buffer,
        VRect rect, GLfloat color[4], GfxTexture *texture, VPoint textureOffset,
        GfxSize textureSize, double rotation, int z_index);
void Graphics_draw_debug_text(Graphics *graphics,
        int ticks_since_last);

// Projection matrix
void Graphics_reset_projection_matrix(Graphics *graphics);
void Graphics_ortho_projection_matrix(Graphics *graphics, double left,
        double right, double top, double bottom, double far, double near);
void Graphics_scale_projection_matrix(Graphics *graphics, double x,
        double y, double z);
void Graphics_rotate_projection_matrix(Graphics *graphics, double rot_degs,
                                       double x, double y, double z);
void Graphics_translate_projection_matrix(Graphics *graphics,
                                         double x, double y, double z);

// Modelview matrix
void Graphics_reset_modelview_matrix(Graphics *graphics);
void Graphics_scale_modelview_matrix(Graphics *graphics,
                                     double x, double y, double z);
void Graphics_rotate_modelview_matrix(Graphics *graphics, double rot_degs,
                                       double x, double y, double z);
void Graphics_translate_modelview_matrix(Graphics *graphics,
                                         double x, double y, double z);

// Shader
GLuint Graphics_load_shader(Graphics *graphics, char *vert_name,
        char *frag_name, GLuint *compiled_program);
GfxShader *Graphics_get_shader(Graphics *graphics, char *name);
void Graphics_use_shader(Graphics *graphics, GfxShader *shader);
int Graphics_init(void *self);
void Graphics_log_shader(GLuint shader);
void Graphics_log_program(GLuint program);

// Textures
GfxTexture *Graphics_texture_from_image(Graphics *graphics, const char *image_name);

// Sprites
struct Sprite;
void Graphics_draw_sprite(Graphics *graphics, struct Sprite *sprite,
                          struct DrawBuffer *draw_buffer, VRect rect,
                          GLfloat color[4], double rot_degs, int z_index);
struct Sprite *Graphics_sprite_from_image(Graphics *graphics, const char *image_name,
    GfxSize cell_size, int padding);

extern Object GraphicsProto;

#endif
#ifndef __stepper_h
#define __stepper_h

typedef struct Stepper {
    float steps_per_second;
    unsigned long stack;

    unsigned long step_skip;
    unsigned long accumulator;
} Stepper;

Stepper *Stepper_create();
void Stepper_destroy(Stepper *stepper);
void Stepper_set_steps_per_second(Stepper *stepper, float steps_per_second);
unsigned long Stepper_update(Stepper *stepper, long unsigned int step_ticks);
int Stepper_reset(Stepper *stepper);
int Stepper_pop(Stepper *stepper);
unsigned long Stepper_clear(Stepper *stepper);

#endif
#ifndef __physics_h
#define __physics_h

typedef struct Physics {
    Stepper *stepper;
} Physics;

Physics *Physics_create();
void Physics_destroy(Physics *physics);

#endif
#ifndef __engine_h
#define __engine_h

#include <sys/time.h>
#include <lcthw/list.h>

typedef struct EngineTimer {
    struct timeval started_at;
    struct timeval paused_at;
    unsigned long pause_skip;
    int paused;
} EngineTimer;

typedef char *(*Engine_resource_path_func)(const char *filename);
typedef struct Engine {
    Audio *audio;
    Input *input;
    Graphics *graphics;
    Physics *physics;
    Scripting *scripting;

    List *easers;

    Engine_resource_path_func resource_path;
    Engine_resource_path_func project_path;
    EngineTimer timer;

    short int reg_initialized;
    short int frame_now;
    long unsigned int frame_ticks;
    long unsigned int frame_skip;
    long unsigned int last_frame_at;
} Engine;

Engine *Engine_create(Engine_resource_path_func path_func,
                      Engine_resource_path_func project_path_func,
                      const char *boot_script, void **sdl_screen);
void Engine_set_resource_path(Engine *engine,
                              Engine_resource_path_func resource_path);
void Engine_set_project_path(Engine *engine,
                             Engine_resource_path_func project_path);
void Engine_destroy(Engine *engine);
int Engine_bootstrap(Engine **engine, void **sdl_screen);
void Engine_regulate(Engine *engine);

void Engine_pause_time(Engine *engine);
void Engine_resume_time(Engine *engine);
unsigned long Engine_get_ticks(Engine *engine);

struct Scene;
struct Scene *Engine_get_current_scene(Engine *engine);
void Engine_frame_end(Engine *engine);

Easer *Engine_gen_easer(Engine *engine, int length_ms, Easer_curve curve);
void Engine_update_easers(Engine *engine);

FILE *Engine_open_resource(Engine *engine, char *filename);
int Engine_load_resource(Engine *engine, char *filename, unsigned char **out,
                         GLint *size);

#ifdef DABES_IOS
#define Engine_log(A, ...) Engine_log_iOS(A, ##__VA_ARGS__)
void Engine_log_iOS(char *fmt, ...);
#else
#define Engine_log(A, ...) debug(A, ##__VA_ARGS__)
#endif

#endif
#ifndef __gzip_h
#define __gzip_h

unsigned long int decompress_data(unsigned char* abSrc, unsigned long nLenSrc, unsigned char** abDst, int nLenDst);
  
#endif
#ifndef __fixture_h
#define __fixture_h

typedef struct Fixture {
    Object proto;
    void *world;
    double time_scale;

    VPoint center;
    double width;
    double height;

    double restitution;
    double mass;
    double drag;
    double surface_area;

    double rotation_radians;
    double angular_velocity;
    double angular_acceleration;
    double moment_of_inertia;

    VPoint velocity;
    VPoint acceleration;

    double step_dt;
    VPoint step_force;
    double step_torque;
    VPoint step_displacement;
    VPoint step_velocity;
    VPoint step_acceleration;
    double step_rotation;
    double step_angular_velocity;
    double step_angular_acceleration;

    Controller *controller;
    VPoint input_acceleration;

    int on_ground;
    int moving;
    int colliding;

    VRect history[FIXTURE_HISTORY_LENGTH];
    List *collisions;
    List *walls;
} Fixture;

int Fixture_init(void *self);
void Fixture_destroy(void *self);
void Fixture_set_rotation_degrees(Fixture *fixture, double degrees);
void Fixture_set_wh(Fixture *fixture, double w, double h);
void Fixture_set_mass(Fixture *fixture, double m);
double Fixture_rotation_degrees(Fixture *fixture);
VRect Fixture_base_box(Fixture *fixture);
VRect Fixture_real_box(Fixture *fixture);
VRect Fixture_display_rect(Fixture *fixture);
VPoint Fixture_display_center(Fixture *fixture);

void Fixture_step_reset(Physics *physics, Fixture *fixture, double advance_ms);
void Fixture_step_displace(Physics *physics, Fixture *fixture);
void Fixture_step_apply_environment(Physics *physics, Fixture *fixture);
void Fixture_step_apply_forces(Physics *physics, Fixture *fixture);
void Fixture_step_control(Fixture *fixture, Controller *controller);
void Fixture_step_commit(Physics *physics, Fixture *fixture);

extern Object FixtureProto;

typedef struct FixtureCollision {
    VPoint poc;
    VPoint collision_normal;
    VPoint mtv;
    Fixture *collider;
} FixtureCollision;

#endif
#ifndef __body_h
#define __body_h
#include <chipmunk/chipmunk.h>
#include <lcthw/list.h>

struct Entity;
struct Engine;
struct Scene;
typedef struct {
  struct Engine *engine;
  struct Entity *entity;
  struct Scene *scene;
  int on_ground;
} BodyStateData;

struct Body;
struct Sensor;
typedef struct BodyProto {
    int (*init)(struct Body *body, float w, float h, float mass,
            int can_rotate);
    void (*cleanup)(struct Body *body);

    VRect (*gfx_rect)(struct Body *body, float pixels_per_meter, int rotate);
    VPoint (*gfx_center)(struct Body *body, float pixels_per_meter);

    void (*add_sensor)(struct Body *body, struct Sensor *sensor);
    void (*remove_sensor)(struct Body *body, struct Sensor *sensor);

    void (*apply_force)(struct Body *body, VPoint force, VPoint offset);
    void (*set_hit_box)(struct Body *body, float w, float h, VPoint offset);

    VPoint (*get_pos)(struct Body *body);
    void (*set_pos)(struct Body *body, VPoint pos);
    VPoint (*get_velo)(struct Body *body);
    void (*set_velo)(struct Body *body, VPoint velo);
    VPoint (*get_force)(struct Body *body);
    void (*set_force)(struct Body *body, VPoint force);
    float (*get_angle)(struct Body *body);
    void (*set_angle)(struct Body *body, float angle);
    float (*get_friction)(struct Body *body);
    void (*set_friction)(struct Body *body, float friction);
    float (*get_elasticity)(struct Body *body);
    void (*set_elasticity)(struct Body *body, float elasticity);
    float (*get_mass)(struct Body *body);
    void (*set_mass)(struct Body *body, float mass);
    int (*get_can_rotate)(struct Body *body);
    void (*set_can_rotate)(struct Body *body, int can_rotate);
    int (*get_is_rogue)(struct Body *body);
    void (*set_is_rogue)(struct Body *body, int is_rogue);
    int (*get_is_static)(struct Body *body);
    void (*set_is_static)(struct Body *body, int is_static);
} BodyProto;

typedef struct Body {
    BodyProto proto;
    BodyStateData state;

    Fixture *fixture;

    cpSpace *cp_space;
    cpShape *cp_shape;
    cpBody *cp_body;

    int is_rogue;
    int is_static;
    int can_rotate;
    float mass;
    float w;
    float h;

    VPoint draw_offset;

    List *sensors;
} Body;

Body *Body_create(BodyProto proto, float w, float h, float mass,
        int can_rotate);
void Body_destroy(Body *body);
void Body_add_sensor(Body *body, struct Sensor *sensor);
void Body_remove_sensor(Body *body, struct Sensor *sensor);

#endif
#ifndef __body_bindings_h
#define __body_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Body_lib;
extern const char *luab_Body_metatable;
typedef Scripting_userdata_for(Body) Body_userdata;
Scripting_caster_for(Body, luaL_tobody);

int luaopen_dabes_body(lua_State *L);

#endif
#ifndef __chipmunk_body_h
#define __chipmunk_body_h

extern BodyProto ChipmunkBodyProto;

#endif
#ifndef __sprite_h
#define __sprite_h
#include <lcthw/hashmap.h>

typedef struct SpriteFrame {
    VPoint offset;
} SpriteFrame;

typedef struct SpriteAnimation {
    int num_frames;
    int loop_start;
    int current_index;
    int repeats;
    Stepper *stepper;
    int frames[];
} SpriteAnimation;

SpriteAnimation *SpriteAnimation_create(int num_frames, int frames[]);
void SpriteAnimation_destroy(SpriteAnimation *animation);

////////////////////////////////////////////////////////////////////////////////

typedef enum {
    SPRITE_DIR_FACING_RIGHT = 0,
    SPRITE_DIR_FACING_LEFT  = 180
} SpriteDirection;

typedef struct Sprite {
    GfxTexture *texture;
    GfxSize cell_size;
    int padding;
    int rows;
    int cols;
    int num_frames;

    Hashmap *animations;
    SpriteAnimation *current_animation;

    SpriteDirection direction;
    int current_frame;
    SpriteFrame frames[];
} Sprite;

Sprite *Sprite_create(GfxTexture *texture, GfxSize cell_size, int padding);
void Sprite_destroy(Sprite *sprite);
void Sprite_update(Sprite *sprite, Engine *engine);

int Sprite_add_animation(Sprite *sprite, SpriteAnimation *animation,
        const char *name);
int Sprite_use_animation(Sprite *sprite, const char *name);

void SpriteAnimation_update(SpriteAnimation *animation, Engine *engine);

#endif
#ifndef __entity_h
#define __entity_h
#include <chipmunk/chipmunk.h>

typedef enum {
    EntityPhysicsShapeTypeFixture = 0,
    EntityPhysicsShapeTypeCPShape
} EntityPhysicsShapeType;

struct Scene;
typedef struct Entity {
    Controller *controller;
    Sprite *sprite;
    Body *body;
    struct Scene *scene;
    GLfloat alpha;

    int pixels_per_meter;
    int z_index;
  
    int selected;
} Entity;

struct Engine;
struct DrawBuffer;

Entity *Entity_create();
void Entity_destroy(Entity *entity);
void Entity_render(Entity *self, struct Engine *engine,
                   struct DrawBuffer *draw_buffer);
void Entity_assign_controller(Entity *entity, Controller *controller);
void Entity_update(Entity *entity, struct Engine *engine);
VPoint Entity_center(Entity *entity);
VRect Entity_real_rect(Entity *entity);
VRect Entity_bounding_rect(Entity *entity);
void Entity_set_z_index(Entity *entity, int z_index);
int Entity_z_cmp(void **a, void **b);

#endif
#ifndef __entity_bindings_h
#define __entity_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Entity_lib;
extern const char *luab_Entity_metatable;
typedef Scripting_userdata_for(Entity) Entity_userdata;
Scripting_caster_for(Entity, luaL_toentity);

int luaopen_dabes_entity(lua_State *L);

#endif
#ifndef __sensor_h
#define __sensor_h
#include <chipmunk/chipmunk.h>
#include <lcthw/list.h>

typedef struct Sensor {
    Body *body;

    float w;
    float h;
    VPoint offset;

    cpSpace *cp_space;
    cpShape *cp_shape;

    int on_static;
    List *on_sensors;
} Sensor;

Sensor *Sensor_create(float w, float h, VPoint offset);
void Sensor_destroy();
void Sensor_overlap_sensor(Sensor *a, Sensor *b);
void Sensor_separate_sensor(Sensor *a, Sensor *b);

#endif
#ifndef __sensor_bindings_h
#define __sensor_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Sensor_lib;
extern const char *luab_Sensor_metatable;
typedef Scripting_userdata_for(Sensor) Sensor_userdata;
Scripting_caster_for(Sensor, luaL_tosensor);

int luaopen_dabes_sensor(lua_State *L);

#endif
#ifndef __camera_h
#define __camera_h

struct Entity;
typedef struct Camera {
    VPoint focal;
    struct GfxSize screen_size;
    struct GfxSize scene_size;

    int num_entities;
    struct Entity **track_entities;

    int snap_to_scene;
    double max_scale;
    double min_scale;

    VRectInset margin;
    double scale;
    double rotation_radians;
    VPoint translation;
} Camera;

Camera *Camera_create(int width, int height);
void Camera_track_entities(Camera *camera, int num_entities,
        struct Entity **entities);
void Camera_track(Camera *camera);
void Camera_destroy(Camera *camera);
void Graphics_project_camera(Graphics *graphics, Camera *camera);
VRect Camera_base_rect(Camera *camera);
VRect Camera_visible_rect(Camera *camera);
VRect Camera_tracking_rect(Camera *camera);
VRect Camera_project_rect(Camera *camera, VRect rect, int translation);
void Camera_debug(Camera *camera, Graphics *graphics);

// World point -> screen point
VPoint Camera_project_point(Camera *camera, VPoint point, int translation);

// Screen point -> world point
VPoint Camera_cast_point(Camera *camera, VPoint point);

#endif
#ifndef __parallax_h
#define __parallax_h
#include <lcthw/darray.h>

typedef struct ParallaxLayer {
    GfxTexture *texture;
    VPoint offset;
    double scale;
    double p_factor;
    double y_wiggle;
} ParallaxLayer;

ParallaxLayer *ParallaxLayer_create(GfxTexture *tex);

typedef struct Parallax {
    DArray *layers;
    Camera *camera;
    GfxSize level_size;
    VVector4 sky_color;
    VVector4 sea_color;
    double y_wiggle;
    double sea_level;
} Parallax;

Parallax *Parallax_create();
void Parallax_destroy(Parallax *parallax);
int Parallax_add_layer(Parallax *parallax, ParallaxLayer *layer);
void Parallax_render(Parallax *parallax, Graphics *graphics);

#endif
#ifndef __tile_map_h
#define __tile_map_h
#include <lcthw/hashmap.h>
#include <lcthw/darray.h>

//TODO: objectgroup
//TODO: properties

extern const unsigned FLIPPED_HORIZONTALLY_FLAG;
extern const unsigned FLIPPED_VERTICALLY_FLAG;
extern const unsigned FLIPPED_DIAGONALLY_FLAG;

// Only PNG
// Doesn't support: format, trans
typedef struct Tileset {
    int spacing;
    int margin;
    GfxSize tile_size;
    uint32_t first_gid;
    char *name;
    char *img_src;
    GfxTexture *texture;
} Tileset;

void Tileset_destroy(Tileset *tileset);

typedef struct TilesetTile {
  uint32_t gid;
  Tileset *tileset;
  VPoint tl;
  GfxSize size;
} TilesetTile;

typedef struct TileMapLayer {
    char *name;
    double opacity;
    int visible;
    int gid_count;
    uint32_t *tile_gids;
    GfxTexture *atlas;
    uint8_t *raw_atlas;
    Tileset *tileset;
} TileMapLayer;

TileMapLayer *TileMapLayer_create();
void TileMapLayer_destroy(TileMapLayer *layer);

// Only orthogonal
typedef struct TileMap {
  int rows;
  int cols;
  GfxSize tile_size;
  DArray *tilesets;
  DArray *layers;
  float meters_per_tile;
} TileMap;

TileMap *TileMap_create();
void TileMap_destroy(TileMap *map);
void TileMap_render(TileMap *map, Graphics *graphics, int pixels_per_meter);
TilesetTile *TileMap_resolve_tile_gid(TileMap *map, uint32_t gid);
GfxSize TileMap_draw_size(TileMap *map, int pixels_per_meter);

void TileMapLayer_draw(TileMapLayer *layer, TileMap *map, Graphics *graphics);

#endif
#ifndef __physics_world_grid_h
#define __physics_world_grid_h

typedef enum {
    WORLDGRIDMEMBER_FIXTURE,
    WORLDGRIDMEMBER_TILE
} WorldGridMemberType;

typedef struct {
    WorldGridMemberType member_type;
    union {
        Fixture *fixture;
        void *raw;
    };
} WorldGridMember;

int WorldGridMember_is_equal(WorldGridMember *a, WorldGridMember *b);

typedef struct WorldGridPoint {
    WorldGridMember owner;
    VPoint point;
} WorldGridPoint;

WorldGridPoint *WorldGridPoint_create(VPoint point, WorldGridMember owner);
void WorldGridPoint_destroy(WorldGridPoint *wgpoint);
int WorldGridPoint_is(WorldGridPoint *wgpoint, VPoint point,
        WorldGridMember owner);

typedef struct WorldGridCell {
    int row;
    int col;
    List *points;
} WorldGridCell;

WorldGridCell *WorldGridCell_create(int row, int col);
void WorldGridCell_destroy(WorldGridCell *cell);

typedef struct WorldGrid {
    int rows;
    int cols;
    double grid_size;
    DArray *cells;
} WorldGrid;

WorldGrid *WorldGrid_create(int rows, int cols, double grid_size);
void WorldGrid_destroy(WorldGrid *grid);

int WorldGrid_update_fixture(WorldGrid *grid, Fixture *fixture);

int WorldGrid_add_fixture(WorldGrid *grid, Fixture *fixture);
int WorldGrid_add_box(WorldGrid *grid, VRect box, WorldGridMember owner);
int WorldGrid_add_point(WorldGrid *grid, VPoint point,
        WorldGridMember owner);

int WorldGrid_remove_fixture(WorldGrid *grid, Fixture *fixture);
int WorldGrid_remove_box(WorldGrid *grid, VRect box, WorldGridMember owner);
int WorldGrid_remove_point(WorldGrid *grid, VPoint point,
        WorldGridMember owner);

WorldGridCell *WorldGrid_cell_for_point(WorldGrid *grid, VPoint point);
List *WorldGrid_cells_for_box(WorldGrid *grid, VRect box);
List *WorldGrid_members_near_fixture(WorldGrid *grid, Fixture *fixture);
VRect WorldGrid_box_for_cell(WorldGrid *grid, int col, int row);

#endif
#ifndef __world_h
#define __world_h

struct World {
    double height;
    double width;
    double grid_size;
    double time_scale;
    double pixels_per_meter;
    double gravity;
    double air_density;
    uint num_fixtures;
    List *fixtures;
    WorldGrid *grid;
};
typedef struct World World;

World *World_create(int cols, int rows);
void World_destroy(World *world);
void World_solve(Physics *physics, World *world, TileMap *tile_map,
                 double advance_ms);
Fixture *World_create_fixture(World *world);
VRect World_floor_box(World *world);
VRect World_ceil_box(World *world);
VRect World_left_wall_box(World *world);
VRect World_right_wall_box(World *world);

#endif
#ifndef __scene_h
#define __scene_h
#include <chipmunk/chipmunk.h>
#include <lcthw/darray.h>

struct Scene;
typedef struct SceneProto {
    void (*start)(struct Scene *scene, Engine *engine);
    void (*stop)(struct Scene *scene, Engine *engine);
    void (*cleanup)(struct Scene *scene, Engine *engine);
    void (*update)(struct Scene *scene, Engine *engine);
    void (*render)(struct Scene *scene, Engine *engine);
    void (*control)(struct Scene *scene, Engine *engine);
    void (*add_entity)(struct Scene *scene, Engine *engine, Entity *entity);
    Entity *(*hit_test)(struct Scene *scene, VPoint g_point);
} SceneProto;

typedef enum {
  kSceneRenderModeNormal = 0,
  kSceneRenderModePhysicsDebug = 1
} SceneRenderMode;

typedef enum {
  kSceneNotSelecting = 0,
  kSceneSelectingForCamera
} SceneEntitySelectionMode;

typedef struct Scene {
    SceneProto proto;
    void *context;
    char *name;

    GfxTexture *bg_texture; // deprecated

    DArray *entities;
    Music *music;
    Camera *camera;
    union {
      World *world;
      cpSpace *space;
    };
    Parallax *parallax;
    TileMap *tile_map;

    VVector4 cover_color;

    short int draw_grid;
    short int debug_camera;
    short int render_mode;
    int started;

    int pixels_per_meter;
  
    SceneEntitySelectionMode selection_mode;
    List *selected_entities;
} Scene;

Scene *Scene_create(Engine *engine, SceneProto proto);
void Scene_destroy(Scene *scene, Engine *engine);
void Scene_restart(Scene *scene, Engine *engine);
void Scene_load_tile_map(Scene *scene, Engine *engine, char *map_file,
                         int abs_path, float meters_per_tile);
void Scene_set_tile_map(Scene *scene, Engine *engine, TileMap *tile_map);
void Scene_draw_debug_grid(Scene *scene, Graphics *graphics);
void Scene_reset_camera(Scene *scene, Engine *engine);
void Scene_render(Scene *scene, Engine *engine);
void Scene_update(Scene *scene, Engine *engine);
void Scene_control(Scene *scene, Engine *engine);

void Scene_set_selection_mode(Scene *scene, SceneEntitySelectionMode mode);
int Scene_select_entities_at(Scene *scene, VPoint screen_point);

#endif
#ifndef __gameobjects_h_
#define __gameobjects_h_


#endif
#ifndef __camera_bindings_h
#define __camera_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Camera_lib;
extern const char *luab_Camera_metatable;
typedef Scripting_userdata_for(Camera) Camera_userdata;
Scripting_caster_for(Camera, luaL_tocamera);

int luaopen_dabes_camera(lua_State *L);

#endif
#ifndef __draw_buffer_h
#define __draw_buffer_h
#include <lcthw/bstrlib.h>
#include <lcthw/darray.h>
#include <lcthw/hashmap.h>
#include <lcthw/hashmap_algos.h>
#include <lcthw/list.h>

typedef struct DrawBufferShape {
    int num_points;
    int num_vectors;
    VMatrix vectors[];
} DrawBufferShape;

typedef struct DrawBufferTexture {
    GfxTexture *texture;
    bstring key;
} DrawBufferTexture;

typedef struct DrawBufferLayer {
    int z_index;
    DArray *textures;
    Hashmap *texture_buffers;
} DrawBufferLayer;

DrawBufferLayer *DrawBufferLayer_create(int z_index);
void DrawBufferLayer_buffer(DrawBufferLayer *layer, GfxTexture *texture,
                            int num_points, int num_attrs, VVector4 vectors[]);
void DrawBufferLayer_destroy(DrawBufferLayer *layer);
void DrawBufferLayer_draw(DrawBufferLayer *layer);

typedef struct DrawBuffer {
    List *layers;
} DrawBuffer;

DrawBuffer *DrawBuffer_create();
void DrawBuffer_destroy(DrawBuffer *buffer);
void DrawBuffer_buffer(DrawBuffer *buffer, GfxTexture *texture, int z_index,
                       int num_points, int num_attrs, VVector4 vectors[]);
void DrawBuffer_empty(DrawBuffer *buffer);
void DrawBuffer_draw(DrawBuffer *buffer);

#endif
#ifndef __parallax_bindings_h
#define __parallax_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_ParallaxLayer_lib;
extern const char *luab_ParallaxLayer_metatable;
typedef Scripting_userdata_for(ParallaxLayer) ParallaxLayer_userdata;
Scripting_caster_for(ParallaxLayer, luaL_toparallaxlayer);

extern const char *luab_Parallax_lib;
extern const char *luab_Parallax_metatable;
typedef Scripting_userdata_for(Parallax) Parallax_userdata;
Scripting_caster_for(Parallax, luaL_toparallax);

int luaopen_dabes_parallax(lua_State *L);

#endif
#ifndef __sprite_bindings_h
#define __sprite_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_SpriteAnimation_lib;
extern const char *luab_SpriteAnimation_metatable;
typedef Scripting_userdata_for(SpriteAnimation) SpriteAnimation_userdata;
Scripting_caster_for(SpriteAnimation, luaL_tospriteanimation);

extern const char *luab_Sprite_lib;
extern const char *luab_Sprite_metatable;
typedef Scripting_userdata_for(Sprite) Sprite_userdata;
Scripting_caster_for(Sprite, luaL_tosprite);

int luaopen_dabes_sprite(lua_State *L);

#endif
#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// To get a header file for this, either cut and paste the header,
// or create stb_image.h, #define STBI_HEADER_FILE_ONLY, and
// then include stb_image.c from it.

////   begin header file  ////////////////////////////////////////////////////
//
// Limitations:
//    - no jpeg progressive support
//    - non-HDR formats support 8-bit samples only (jpeg, png)
//    - no delayed line count (jpeg) -- IJG doesn't support either
//    - no 1-bit BMP
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x       -- outputs image width in pixels
//    int *y       -- outputs image height in pixels
//    int *comp    -- outputs # of image components in image file
//    int req_comp -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to easily see if it's opaque.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB; nominally they
// would silently load as BGR, except the existing code should have just
// failed on such iPhone PNGs. But you can disable this conversion by
// by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through.
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).


#ifndef STBI_NO_STDIO

#if defined(_MSC_VER) && _MSC_VER >= 0x1400
#define _CRT_SECURE_NO_WARNINGS // suppress bogus warnings about fopen()
#endif

#include <stdio.h>
#endif

#define STBI_VERSION 1

enum
{
  STBI_default = 0, // only used for req_comp
  
  STBI_grey       = 1,
  STBI_grey_alpha = 2,
  STBI_rgb        = 3,
  STBI_rgb_alpha  = 4
};

typedef unsigned char stbi_uc;

#ifdef __cplusplus
extern "C" {
#endif
  
  //////////////////////////////////////////////////////////////////////////////
  //
  // PRIMARY API - works on images of any type
  //
  
  //
  // load image by filename, open file, or memory buffer
  //
  
  extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
  
#ifndef STBI_NO_STDIO
  extern stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
  extern stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
  // for stbi_load_from_file, file pointer is left pointing immediately after image
#endif
  
  typedef struct
  {
    int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
    void     (*skip)  (void *user,unsigned n);            // skip the next 'n' bytes
    int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
  } stbi_io_callbacks;
  
  extern stbi_uc *stbi_load_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
  
#ifndef STBI_NO_HDR
  extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
  
#ifndef STBI_NO_STDIO
  extern float *stbi_loadf            (char const *filename,   int *x, int *y, int *comp, int req_comp);
  extern float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);
#endif
  
  extern float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
  
  extern void   stbi_hdr_to_ldr_gamma(float gamma);
  extern void   stbi_hdr_to_ldr_scale(float scale);
  
  extern void   stbi_ldr_to_hdr_gamma(float gamma);
  extern void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_HDR
  
  // stbi_is_hdr is always defined
  extern int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
  extern int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
  extern int      stbi_is_hdr          (char const *filename);
  extern int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO
  
  
  // get a VERY brief reason for failure
  // NOT THREADSAFE
  extern const char *stbi_failure_reason  (void);
  
  // free the loaded image -- this is just free()
  extern void     stbi_image_free      (void *retval_from_stbi_load);
  
  // get image dimensions & components without fully decoding
  extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
  extern int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
  
#ifndef STBI_NO_STDIO
  extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
  extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
  
#endif
  
  
  
  // for image formats that explicitly notate that they have premultiplied alpha,
  // we just return the colors as stored in the file. set this flag to force
  // unpremultiplication. results are undefined if the unpremultiply overflow.
  extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
  
  // indicate whether we should process iphone images back to canonical format,
  // or just pass them through "as-is"
  extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
  
  
  // ZLIB client - used by PNG, available for other purposes
  
  extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
  extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
  extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
  
  extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
  extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
  
  
  // define faster low-level operations (typically SIMD support)
#ifdef STBI_SIMD
  typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);
  // compute an integer IDCT on "input"
  //     input[x] = data[x] * dequantize[x]
  //     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'
  //                             CLAMP results to 0..255
  typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);
  // compute a conversion from YCbCr to RGB
  //     'count' pixels
  //     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B
  //     y: Y input channel
  //     cb: Cb input channel; scale/biased to be 0..255
  //     cr: Cr input channel; scale/biased to be 0..255
  
  extern void stbi_install_idct(stbi_idct_8x8 func);
  extern void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);
#endif // STBI_SIMD
  
  
#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifndef __tile_map_parse_h
#define __tile_map_parse_h

typedef enum {
  TILEMAP_PARSE_OK = 0,
  TILEMAP_PARSE_INVALID_FORMAT = 1,
  TILEMAP_PARSE_INVALID_ORIENTATION = 2,
  TILEMAP_PARSE_MISSING_IMAGE = 3,
  TILEMAP_PARSE_UNKNOWN_ERR = 4
} TileMapParseStatus;

TileMap *TileMap_parse(char *filename, Engine *engine);

#endif
#ifndef __controller_bindings_h
#define __controller_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Controller_lib;
extern const char *luab_Controller_metatable;
typedef Scripting_userdata_for(Controller) Controller_userdata;
Scripting_caster_for(Controller, luaL_tocontroller);

int luaopen_dabes_controller(lua_State *L);

#endif
#ifndef __ortho_chipmunk_scene_h
#define __ortho_chipmunk_scene_h

typedef struct {
    Scene *scene;
    Engine *engine;
} OCSIterData;

typedef enum {
  OCSCollisionTypeEntity = 1,
  OCSCollisionTypeTile = 2,
  OCSCollisionTypeDrawShape = 3,
  OCSCollisionTypeSensor = 4,
  OCSCollisionTypeStaticEntity = 5
} OCSCollisionType;

extern SceneProto OrthoChipmunkSceneProto;

#endif
#ifndef __scene_bindings_h
#define __scene_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Scene_lib;
extern const char *luab_Scene_metatable;

typedef Scripting_userdata_for(Scene) Scene_userdata;

Scripting_caster_for(Scene, luaL_toscene);

int luaopen_dabes_scene(lua_State *L);
Scene *luaL_get_current_scene(lua_State *L);
int luaL_flip_scene(lua_State *L);

#endif
