// THIS FILE IS AUTOMATICALLY GENERATED EACH BUILD!

#ifndef __constants_h
#define __constants_h

#ifdef DABES_IOS
#define FPS 60
#else
#define FPS 60
#endif

#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define DEFAULT_PPM 32

#define NUM_BOXES 100

#define MVMT_RUN_ACCEL 15
#define MVMT_AIR_ACCEL 2 * MVMT_RUN_ACCEL
#define MVMT_TURN_ACCEL 3 * MVMT_RUN_ACCEL
#define MVMT_FRICTION MVMT_RUN_ACCEL
#define MVMT_MAX_VELO 15
#define MVMT_JUMP_VELO_HI -8
#define MVMT_JUMP_VELO_LO -4

#define PHYS_DEFAULT_GRID_SIZE 2.0
#define FIXTURE_HISTORY_LENGTH 10


#endif
#ifndef __dbg_h__
#define __dbg_h__

#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifdef NDEBUG
#define debug(M, ...)
#else
#define debug(M, ...) fprintf(stderr, "DEBUG %s:%d: " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#endif

#define clean_errno() (errno == 0 ? "None" : strerror(errno))

#define log_err(M, ...) fprintf(stderr, "[ERROR] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_warn(M, ...) fprintf(stderr, "[WARN] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

#define log_info(M, ...) fprintf(stderr, "[INFO] (%s:%d) " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

#define check_mem(A) check((A), "Out of memory.")

#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__); errno=0; goto error; }

#define debug_rect(a) \
    debug("(%f, %f), (%f, %f), (%f, %f), (%f, %f)", \
            a.tl.x, a.tl.y, a.tr.x, a.tr.y, a.bl.x, a.bl.y, a.br.x, a.br.y)


#endif
#ifndef __util_h
#define __util_h
#define sign(N) (N > 0) - (N < 0)

#ifndef MIN
#define MIN(A, B) (A < B ? A : B)
#endif
#ifndef MAX
#define MAX(A, B) (A > B ? A : B)
#endif

#define countfunc() \
  static int func_ctr = 0; \
  func_ctr++; \
  printf("%s called %d\n", __func__, func_ctr);

#define fequal(a,b) (fabs((a) - (b)) < FLT_EPSILON)
#define streq(A, B) (strcmp((const char *)A, (const char *)B) == 0)

#endif
#ifndef __prefix_h
#define __prefix_h

#include <math.h>
#include <float.h>

#if !defined(DABES_IOS) && !defined(DABES_MAC)
  #include <assert.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <lcthw/liblcthw.h>
  #include <SDL/SDL.h>
  #include <SDL/SDL_image.h>
  #include <SDL/SDL_opengl.h>
  #include <SDL/SDL_mixer.h>
  #include <SDL/SDL_ttf.h>
  #define DABES_SDL
#endif


extern char *bundlePath__;

#endif

#ifdef DABES_IOS
#define DABES_GLVERSION "gles"
#else
#define DABES_GLVERSION "gl"
#endif

#define shader_path(N) "shaders/" DABES_GLVERSION "/" N

#ifdef __GNUC__
#  define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_ ## x
#endif

#ifdef __GNUC__
#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_ ## x
#else
#  define UNUSED_FUNCTION(x) UNUSED_ ## x
#endif
#ifndef _object_h
#define _object_h

typedef struct {
    char *description;
    int (*init)(void *self);
    void (*describe)(void *self);
    void (*destroy)(void *self);
} Object;

int Object_init(void *self);
void Object_destroy(void *self);
void Object_describe(void *self);
void *Object_new(size_t size, Object proto, char *description);

#define NEW(T, N) Object_new(sizeof(T), T##Proto, N)
#define _(N) proto.N
#define m_(N, M, ...) N->M(N, ##__VA_ARGS__)

#endif
#ifndef __prefix_h
#define __prefix_h

#include <math.h>
#include <float.h>

#if !defined(DABES_IOS) && !defined(DABES_MAC)
  #include <assert.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <lcthw/liblcthw.h>
  #include <SDL/SDL.h>
  #include <SDL/SDL_image.h>
  #include <SDL/SDL_opengl.h>
  #include <SDL/SDL_mixer.h>
  #include <SDL/SDL_ttf.h>
  #define DABES_SDL
#endif


extern char *bundlePath__;

#endif

#ifdef DABES_IOS
#define DABES_GLVERSION "gles"
#else
#define DABES_GLVERSION "gl"
#endif

#define shader_path(N) "shaders/" DABES_GLVERSION "/" N

#ifdef __GNUC__
#  define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
#else
#  define UNUSED(x) UNUSED_ ## x
#endif

#ifdef __GNUC__
#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_ ## x
#else
#  define UNUSED_FUNCTION(x) UNUSED_ ## x
#endif
#ifndef __audio_h
#define __audio_h
#include <pthread.h>
#include <lcthw/list.h>
#if defined(DABES_IOS) || defined(DABES_MAC)
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#else
#include <al/al.h>
#include <al/alc.h>
#endif


typedef struct Audio {
    List *musics;
    List *active_sfx;
    ALCdevice *device;
    ALCcontext *context;

    pthread_t thread;
    pthread_mutex_t run_lock;
    pthread_mutex_t music_lock;
    pthread_mutex_t sfx_lock;
} Audio;

Audio *Audio_create();
int Audio_check();

struct Engine;
void Audio_destroy(Audio *audio);

struct Music;
struct Music *Audio_gen_music(Audio *audio, int num_files, char *files[]);
void Audio_destroy_music(Audio *audio, struct Music *music);

struct Sfx;
struct Sfx *Audio_gen_sfx(Audio *audio, char *filename);
void Audio_destroy_sfx(Audio *audio, struct Sfx *sfx);

void Audio_sweep(Audio *audio, struct Engine *engine);

#endif
#ifndef __ogg_stream_h
#define __ogg_stream_h
#include <stdio.h>
#include <stdlib.h>

#if defined(DABES_IOS) || defined(DABES_MAC)
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#else
#include <al/al.h>
#include <al/alc.h>
#endif

#include <ogg/ogg.h>
#include <vorbis/codec.h>
#include <vorbis/vorbisenc.h>
#include <vorbis/vorbisfile.h>


#define OGG_BUFFER_COUNT 3

typedef struct OggStream {
    char *filename;
    FILE *file;
    OggVorbis_File stream;
    vorbis_info *vorbis_info;
    vorbis_comment *vorbis_comment;

    int buf_count;
    ALuint buffers[OGG_BUFFER_COUNT];
    ALuint source;
    ALenum format;

    int started;
    int should_loop;
    int eof;
    int ended;
} OggStream;

OggStream *OggStream_create(char *file, ALuint source);
OggStream *OggStream_clone(OggStream *ogg_stream);
void OggStream_destroy(OggStream *ogg_stream);
void OggStream_debug(OggStream *ogg_stream);
int OggStream_stop(OggStream *ogg_stream);
int OggStream_play(OggStream *ogg_stream);
int OggStream_playing(OggStream *ogg_stream);
int OggStream_update(OggStream *ogg_stream);
void OggStream_rewind(OggStream *ogg_stream);

#endif
#ifndef __audio_h
#define __audio_h
#include <pthread.h>
#include <lcthw/list.h>
#if defined(DABES_IOS) || defined(DABES_MAC)
#include <OpenAL/al.h>
#include <OpenAL/alc.h>
#else
#include <al/al.h>
#include <al/alc.h>
#endif


typedef struct Audio {
    List *musics;
    List *active_sfx;
    ALCdevice *device;
    ALCcontext *context;

    pthread_t thread;
    pthread_mutex_t run_lock;
    pthread_mutex_t music_lock;
    pthread_mutex_t sfx_lock;
} Audio;

Audio *Audio_create();
int Audio_check();

struct Engine;
void Audio_destroy(Audio *audio);

struct Music;
struct Music *Audio_gen_music(Audio *audio, int num_files, char *files[]);
void Audio_destroy_music(Audio *audio, struct Music *music);

struct Sfx;
struct Sfx *Audio_gen_sfx(Audio *audio, char *filename);
void Audio_destroy_sfx(Audio *audio, struct Sfx *sfx);

void Audio_sweep(Audio *audio, struct Engine *engine);

#endif
#ifndef __music_h
#define __music_h
#include <lcthw/list.h>
#include <OpenAL/al.h>
#include <pthread.h>

struct Scene;
typedef struct Music {
    double volume;
    List *ogg_streams;
    int playing;
    int _needs_play;

    int ended;
    int _needs_end;

    int loop;
    int initialized;
    ALuint source;
    OggStream *active_stream;

    struct Scene *scene;

    pthread_mutex_t lock;

    int num_files;
    char *ogg_files[];
} Music;

#pragma mark - Main thread
Music *Music_load(int num_files, char *ogg_files[]);
void Music_destroy(Music *music);
void Music_play(Music *music);
void Music_pause(Music *music);
void Music_end(Music *music);
void Music_set_volume(Music *music, double volume);
void Music_set_loop(Music *music, int loop);

#pragma mark - Audio thread
void Music_t_update(Music *music);

#endif
#ifndef __binding_macros_h
#define __binding_macros_h

// Defining Types
#define Scripting_userdata_for(STYPE) \
struct STYPE ## _userdata { \
    lua_State *L; \
    STYPE *p; \
}

#define Scripting_caster_for(STYPE, FNAME) \
static inline STYPE *FNAME(lua_State *L, int narg) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) \
        luaL_checkudata(L, narg, luab_ ## STYPE ## _metatable); \
    check(ud != NULL, "Object at %d is not type %s", narg, #STYPE); \
    check(ud->p != NULL, "Userdata has no %s object", #STYPE); \
    return ud->p; \
error: \
    return NULL; \
}

#define Scripting_null_closer(STYPE) \
static inline int luab_ ## STYPE ## _close(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    ud->p = NULL; \
    return 0; \
}

#define Scripting_destroy_closer(STYPE) \
static inline int luab_ ## STYPE ## _close(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    if (ud->p) { \
        STYPE ## _destroy(ud->p); \
    } \
    ud->p = NULL; \
    return 0; \
}

// Property accessor generation, basic types
#define Scripting_num_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    check(lua_isnumber(L, 2), \
            "Please provide a number to set "#STYPE"->"#SPROP); \
    lua_Number num = lua_tonumber(L, 2); \
    STYPE *s = ud->p; \
    s->SPROP = num; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_num_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_Number ret = s->SPROP; \
    lua_pushnumber(L, ret); \
    return 1; \
}

#define Scripting_bool_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    check(lua_isboolean(L, 2), \
            "Please provide a boolean to set "#STYPE"->"#SPROP); \
    int num = lua_toboolean(L, 2); \
    STYPE *s = ud->p; \
    s->SPROP = num; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_bool_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    int ret = s->SPROP; \
    lua_pushboolean(L, ret); \
    return 1; \
}

#define Scripting_string_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    check(lua_isstring(L, 2), \
            "Please provide a string to set "#STYPE"->"#SPROP); \
    char *string = lua_tostring(L, 2); \
    STYPE *s = ud->p; \
    s->SPROP = string; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_string_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    char *ret = s->SPROP; \
    lua_pushstring(L, ret); \
    return 1; \
}

// Property synthesis, complex types
#define Scripting_VPoint_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_newtable(L); \
    lua_pushinteger(L, 1); \
    lua_pushnumber(L, s->SPROP.x); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 2); \
    lua_pushnumber(L, s->SPROP.y); \
    lua_settable(L, -3); \
    return 1; \
}

#define Scripting_VPoint_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    check(luaL_unpack_exact(L, 2), \
            "Please provide 2 numbers to set " #STYPE "->" #SPROP ); \
    VPoint point = {lua_tonumber(L, -2), lua_tonumber(L, -1)}; \
    lua_pop(L, 2); \
    s->SPROP = point; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_VVector4_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_newtable(L); \
    lua_pushinteger(L, 1); \
    lua_pushnumber(L, s->SPROP.raw[0]); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 2); \
    lua_pushnumber(L, s->SPROP.raw[1]); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 3); \
    lua_pushnumber(L, s->SPROP.raw[2]); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 4); \
    lua_pushnumber(L, s->SPROP.raw[3]); \
    lua_settable(L, -3); \
    return 1; \
}

#define Scripting_VVector4_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    check(luaL_unpack_exact(L, 4), \
            "Please provide 4 numbers to set " #STYPE "->" #SPROP ); \
    VVector4 vertex = {.raw = {lua_tonumber(L, -4), lua_tonumber(L, -3), \
        lua_tonumber(L, -2), lua_tonumber(L, -1)}}; \
    lua_pop(L, 4); \
    s->SPROP = vertex; \
    return 1; \
error: \
    return 0; \
}

#define Scripting_GfxSize_getter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _get_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    lua_newtable(L); \
    lua_pushinteger(L, 1); \
    lua_pushnumber(L, s->SPROP.w); \
    lua_settable(L, -3); \
    lua_pushinteger(L, 2); \
    lua_pushnumber(L, s->SPROP.h); \
    lua_settable(L, -3); \
    return 1; \
}

#define Scripting_GfxSize_setter(STYPE, SPROP) \
static inline int luab_ ## STYPE ## _set_ ## SPROP(lua_State *L) { \
    STYPE ## _userdata *ud = (STYPE ## _userdata *) luaL_checkudata(L, 1, luab_ ## STYPE ## _metatable); \
    STYPE *s = ud->p; \
    check(luaL_unpack_exact(L, 2), \
            "Please provide 2 numbers to set " #STYPE "->" #SPROP ); \
    GfxSize size = {lua_tonumber(L, -2), lua_tonumber(L, -1)}; \
    lua_pop(L, 2); \
    s->SPROP = size; \
    return 1; \
error: \
    return 0; \
}

#endif
#ifndef __vpoint_h
#define __vpoint_h
#include <chipmunk/chipmunk.h>

typedef enum {
  VPointRelWithin = 0,
  VPointRelXLess = 1 << 0,
  VPointRelXMore = 1 << 1,
  VPointRelYLess = 1 << 2,
  VPointRelYMore = 1 << 3
} VPointRel;

typedef struct VPoint {
    float x;
    float y;
} VPoint;

static const VPoint VPointZero = {0,0};

VPoint VPoint_make(float x, float y);
VPoint VPoint_add(VPoint a, VPoint b);
VPoint VPoint_subtract(VPoint a, VPoint b);
VPoint VPoint_multiply(VPoint a, VPoint b);
double VPoint_angle(VPoint a, VPoint b);
VPoint VPoint_scale(VPoint a, double b);
double VPoint_dot(VPoint a, VPoint b);
double VPoint_cross(VPoint a, VPoint b);
VPoint VPoint_mid(VPoint a, VPoint b);
VPoint VPoint_rotate(VPoint point, VPoint pivot, double angle_in_rads);
VPoint VPoint_perp(VPoint a);
VPoint VPoint_normalize(VPoint a);
double VPoint_magnitude(VPoint a);
double VPoint_distance(VPoint a, VPoint b);
VPoint VPoint_look_from(VPoint start_point, float angle_rads, float mag);
VPointRel VPoint_rel(VPoint a, VPoint b);

static inline void VPoint_debug(VPoint point, char *msg) {
    debug("<%f, %f> %s", point.x, point.y, msg);
}

////////////////////////////////////////////////////////////////////////////////

typedef struct VPath {
    int num_points;
    VPoint points[];
} VPath;

VPath *VPath_create(VPoint *points, int num_points);
void VPath_destroy(VPath *path);
void VPath_translate(VPath *path, VPoint trans);

#endif
#ifndef __vmatrix_h
#define __vmatrix_h

#ifdef DABES_IOS
#include <GLKit/GLKMath.h>
#include <OpenGLES/ES2/gl.h>
#include <QuartzCore/CoreAnimation.h>
#endif
#ifdef DABES_MAC
#include <OpenGL/OpenGL.h>
#include <GLKit/GLKMath.h>
#include <QuartzCore/CATransform3D.h>
#endif

typedef union VVector3 {
  struct { float x, y, z; };
  struct { float r, g, b; };
  struct { float s, t, p; };
  float v[3];
} VVector3;

VVector3 VVector3_normalize(VVector3 vector);
float VVector3_length(VVector3 vector);

typedef union VVector4 {
  struct {
    float x;
    float y;
    float z;
    float w;
  } packed;
  struct {
    float r;
    float g;
    float b;
    float a;
  } rgba;
  float raw[4];
} VVector4;

extern const VVector4 VVector4Zero;

static const VVector4 VVector4ClearColor = {.raw = {0.0, 0.0, 0.0, 0.0}};
static const VVector4 VVector4BlackColor = {.raw = {0.0, 0.0, 0.0, 1.0}};
static const VVector4 VVector4WhiteColor = {.raw = {1.0, 1.0, 1.0, 1.0}};

typedef union VMatrix {
    struct {
      float m11, m12, m13, m14;
      float m21, m22, m23, m24;
      float m31, m32, m33, m34;
      float m41, m42, m43, m44;
    } gfx;
    float gl[16];
    VVector4 v[4];
#if defined(DABES_IOS) || defined(DABES_MAC)
    CATransform3D ca;
#endif
#ifdef DABES_IOS
    GLKMatrix4 glk;
#endif
} VMatrix;

extern const VMatrix VMatrixIdentity;

VMatrix VMatrix_multiply(VMatrix a, VMatrix b);
VMatrix VMatrix_transpose(VMatrix m);
VMatrix VMatrix_scale(VMatrix matrix, double x, double y, double z);
VMatrix VMatrix_make_rotation(float radians, float x, float y, float z);
VMatrix VMatrix_rotate(VMatrix matrix, double rot_degs, double x, double y,
                       double z);
VMatrix VMatrix_translate(VMatrix matrix, double tx, double ty, double tz);
VMatrix VMatrix_make_ortho(float left, float right, float top,
                           float bottom, float near, float far);
VMatrix VMatrix_make_perspective(float fov_radians, float aspect, float near,
                                 float far);
VMatrix VMatrix_make_frustum(float left, float right, float top,
                             float bottom, float near, float far);
int VMatrix_is_equal(VMatrix a, VMatrix b);

#endif
#ifndef __scripting_h
#define __scripting_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *SCRIPTING_CL_ENTITY_CONFIG;
extern const char *SCRIPTING_CL_PARALLAX;
extern const char *SCRIPTING_CL_PARALLAX_LAYER;
extern const char *SCRIPTING_ENGINE_REGISTRY_KEY;

typedef void (*Scripting_error_cb)(const char *error);

typedef struct Scripting {
    lua_State *L;
    Scripting_error_cb error_callback;
    Scripting_error_cb panic_callback;
} Scripting;

struct Engine;
Scripting *Scripting_create(struct Engine *engine, const char *boot_script);
void Scripting_destroy(Scripting *scripting);
void Scripting_register_engine(Scripting *scripting, struct Engine *engine);
void Scripting_boot(Scripting *scripting);
void Scripting_update_paths(Scripting *scripting, struct Engine *engine);

int Scripting_call_hook(Scripting *scripting, void *bound, const char *fname);
void *Scripting_ud_return_hook(Scripting *scripting, void *bound,
        const char *fname);
int Scripting_call_dhook(Scripting *scripting, void *bound, const char *fname,
                         ...);

void luaL_register_ud(lua_State *L, int ud_idx, void **ud_prop, void *val);
int luaL_lookup_ud(lua_State *L, void *val);
int luaL_lookup_instance(lua_State *L, void *val);
void luaL_createweakweaktable(lua_State *L);
void luaL_createweakstrongtable(lua_State *L);
void luaL_createstrongweaktable(lua_State *L);
int luab_register_instance(lua_State *L);
struct Engine *luaL_get_engine(lua_State *L);
int luaL_unpack_exact (lua_State *L, int count);

VPoint luaL_tovpoint(lua_State *L, int idx);
int luaL_pushvpoint(lua_State *L, VPoint point);

VVector4 luaL_tovvector4(lua_State *L, int idx);

#define Scripting_bail(L, MSG) { \
    fprintf(stderr, "%s: %s\n", MSG, lua_tostring(L, -1)); \
    return 0; \
}

#endif
#ifndef __music_bindings_h
#define __music_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Music_lib;
extern const char *luab_Music_metatable;

typedef Scripting_userdata_for(Music) Music_userdata;

Scripting_caster_for(Music, luaL_tomusic);

int luaopen_dabes_music(lua_State *L);

#endif
#ifndef __sfx_h
#define __sfx_h
#include <OpenAL/al.h>
#include <pthread.h>

typedef struct Sfx {
    double volume;
    int playing;
    int _needs_play;

    int ended;
    int _needs_end;

    int initialized;
    ALuint source;

    pthread_mutex_t lock;

    char *filename;
    OggStream *ogg_stream;
} Sfx;

#pragma mark - Main Thread
Sfx *Sfx_load(char *filename);
void Sfx_destroy(Sfx *sfx);
void Sfx_play(Sfx *sfx);
void Sfx_end(Sfx *sfx);
void Sfx_set_volume(Sfx *sfx, double volume);

#pragma mark - Audio thread
void Sfx_t_update(Sfx *sfx);

#endif
#ifndef __sfx_bindings
#define __sfx_bindings
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Sfx_lib;
extern const char *luab_Sfx_metatable;

typedef Scripting_userdata_for(Sfx) Sfx_userdata;

Scripting_caster_for(Sfx, luaL_tosfx);

int luaopen_dabes_sfx(lua_State *L);

#endif
/*
 
 https://github.com/superwills/NibbleAndAHalf
 base64.h -- Fast base64 encoding and decoding.
 version 1.0.0, April 17, 2013 143a
 
 Copyright (C) 2013 William Sherif
 
 This software is provided 'as-is', without any express or implied
 warranty.  In no event will the authors be held liable for any damages
 arising from the use of this software.
 
 Permission is granted to anyone to use this software for any purpose,
 including commercial applications, and to alter it and redistribute it
 freely, subject to the following restrictions:
 
 1. The origin of this software must not be misrepresented; you must not
 claim that you wrote the original software. If you use this software
 in a product, an acknowledgment in the product documentation would be
 appreciated but is not required.
 2. Altered source versions must be plainly marked as such, and must not be
 misrepresented as being the original software.
 3. This notice may not be removed or altered from any source distribution.
 
 William Sherif
 will.sherif@gmail.com
 
 YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz
 
 */
#ifndef BASE64_H
#define BASE64_H

#include <stdio.h>
#include <stdlib.h>

const static char* b64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" ;

// maps A=>0,B=>1..
const static unsigned char unb64[]={
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //10
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //20
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //30
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //40
  0,   0,   0,  62,   0,   0,   0,  63,  52,  53, //50
  54,  55,  56,  57,  58,  59,  60,  61,   0,   0, //60
  0,   0,   0,   0,   0,   0,   1,   2,   3,   4, //70
  5,   6,   7,   8,   9,  10,  11,  12,  13,  14, //80
  15,  16,  17,  18,  19,  20,  21,  22,  23,  24, //90
  25,   0,   0,   0,   0,   0,   0,  26,  27,  28, //100
  29,  30,  31,  32,  33,  34,  35,  36,  37,  38, //110
  39,  40,  41,  42,  43,  44,  45,  46,  47,  48, //120
  49,  50,  51,   0,   0,   0,   0,   0,   0,   0, //130
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //140
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //150
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //160
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //170
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //180
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //190
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //200
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //210
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //220
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //230
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //240
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0, //250
  0,   0,   0,   0,   0,   0,
}; // This array has 255 elements

// Converts binary data of length=len to base64 characters.
// Length of the resultant string is stored in flen
// (you must pass pointer flen).
static inline char* base64_encode( const void* binaryData, int len, int *flen )
{
  const unsigned char* bin = (const unsigned char*) binaryData ;
  char* res ;
  
  int rc = 0 ; // result counter
  int byteNo ; // I need this after the loop
  
  int modulusLen = len % 3 ;
  int pad = ((modulusLen&1)<<1) + ((modulusLen&2)>>1) ; // 2 gives 1 and 1 gives 2, but 0 gives 0.
  
  *flen = 4*(len + pad)/3 ;
  res = (char*) malloc( *flen + 1 ) ; // and one for the null
  if( !res )
  {
    puts( "ERROR: base64 could not allocate enough memory." ) ;
    puts( "I must stop because I could not get enough" ) ;
    return 0;
  }
  
  for( byteNo = 0 ; byteNo <= len-3 ; byteNo+=3 )
  {
    unsigned char BYTE0=bin[byteNo];
    unsigned char BYTE1=bin[byteNo+1];
    unsigned char BYTE2=bin[byteNo+2];
    res[rc++]  = b64[ BYTE0 >> 2 ] ;
    res[rc++]  = b64[ ((0x3&BYTE0)<<4) + (BYTE1 >> 4) ] ;
    res[rc++]  = b64[ ((0x0f&BYTE1)<<2) + (BYTE2>>6) ] ;
    res[rc++]  = b64[ 0x3f&BYTE2 ] ;
  }
  
  if( pad==2 )
  {
    res[rc++] = b64[ bin[byteNo] >> 2 ] ;
    res[rc++] = b64[ (0x3&bin[byteNo])<<4 ] ;
    res[rc++] = '=';
    res[rc++] = '=';
  }
  else if( pad==1 )
  {
    res[rc++]  = b64[ bin[byteNo] >> 2 ] ;
    res[rc++]  = b64[ ((0x3&bin[byteNo])<<4)   +   (bin[byteNo+1] >> 4) ] ;
    res[rc++]  = b64[ (0x0f&bin[byteNo+1])<<2 ] ;
    res[rc++] = '=';
  }
  
  res[rc]=0; // NULL TERMINATOR! ;)
  return res ;
}

static inline unsigned char* base64_decode( const char* ascii, int len, int *flen )
{
  const unsigned char *safeAsciiPtr = (const unsigned char*)ascii ;
  unsigned char *bin ;
  int cb=0;
  int charNo;
  int pad = 0 ;
  
  if( len < 2 ) { // 2 accesses below would be OOB.
    // catch empty string, return NULL as result.
    puts( "ERROR: You passed an invalid base64 string (too short). You get NULL back." ) ;
    *flen=0;
    return 0 ;
  }
  if( safeAsciiPtr[ len-1 ]=='=' )  ++pad ;
  if( safeAsciiPtr[ len-2 ]=='=' )  ++pad ;
  
  *flen = 3*len/4 - pad ;
  bin = (unsigned char*)malloc( *flen ) ;
  if( !bin )
  {
    puts( "ERROR: unbase64 could not allocate enough memory." ) ;
    puts( "I must stop because I could not get enough" ) ;
    return 0;
  }
  
  for( charNo=0; charNo <= len - 4 - pad ; charNo+=4 )
  {
    int A=unb64[safeAsciiPtr[charNo]];
    int B=unb64[safeAsciiPtr[charNo+1]];
    int C=unb64[safeAsciiPtr[charNo+2]];
    int D=unb64[safeAsciiPtr[charNo+3]];
    
    bin[cb++] = (A<<2) | (B>>4) ;
    bin[cb++] = (B<<4) | (C>>2) ;
    bin[cb++] = (C<<6) | (D) ;
  }
  
  if( pad==1 )
  {
    int A=unb64[safeAsciiPtr[charNo]];
    int B=unb64[safeAsciiPtr[charNo+1]];
    int C=unb64[safeAsciiPtr[charNo+2]];
    
    bin[cb++] = (A<<2) | (B>>4) ;
    bin[cb++] = (B<<4) | (C>>2) ;
  }
  else if( pad==2 )
  {
    int A=unb64[safeAsciiPtr[charNo]];
    int B=unb64[safeAsciiPtr[charNo+1]];
    
    bin[cb++] = (A<<2) | (B>>4) ;
  }
  
  return bin ;
}

#endif
#ifndef __console_h
#define __console_h

struct Console;
struct Engine;
typedef struct ConsoleProto {
  void (*log)(struct Console *console, char *str, char *level);
} ConsoleProto;

typedef struct Console {
  ConsoleProto proto;
} Console;

Console *Console_create(ConsoleProto proto);
void Console_destroy(struct Console *console);

extern ConsoleProto STDIOConsoleProto;

#endif
#ifndef __controller_h
#define __controller_h

typedef enum {
    CONTROLLER_DPAD_NONE = 0,
    CONTROLLER_DPAD_UP = 1<<0,
    CONTROLLER_DPAD_RIGHT = 1<<1,
    CONTROLLER_DPAD_DOWN = 1<<2,
    CONTROLLER_DPAD_LEFT = 1<<3
} Controller_dpad_direction;

typedef enum {
    CONTROLLER_TOUCH_NONE = 0,
    CONTROLLER_TOUCH_HOLD = 1,
    CONTROLLER_TOUCH_HOLD_CHANGED = 1 << 1,
    CONTROLLER_TOUCH_MOVED = 1 << 2
} ControllerTouchState;

typedef struct Controller {
    Controller_dpad_direction dpad;
    int jump;

    ControllerTouchState touch_state;
    VPoint touch_pos;
} Controller;

Controller *Controller_create();
void Controller_destroy(Controller *controller);
void Controller_reset(Controller *controller);
void Controller_reset_touches(Controller *controller);
void Controller_debug_touch_state(Controller *controller, const char *msg);

extern Object ControllerProto;

#endif
#ifndef __input_h
#define __input_h

#define INPUT_NUM_CONTROLLERS 4

typedef enum InputStyle {
    INPUT_STYLE_LEFT_RIGHT = 0,
    INPUT_STYLE_TOUCHPAD,
    INPUT_STYLE_USER0 = 16,
    INPUT_STYLE_USER1,
    INPUT_STYLE_USER2,
    INPUT_STYLE_USER3,
    INPUT_STYLE_USER4,
    INPUT_STYLE_USER5,
    INPUT_STYLE_USER6,
    INPUT_STYLE_USER7,
    INPUT_STYLE_USER8
} InputStyle;

typedef struct Input {
    Controller *controllers[INPUT_NUM_CONTROLLERS];
    int game_quit;
    int debug_scene_draw_grid;
    int cam_reset;
    int cam_zoom;
    int cam_rotate;
    VPoint cam_focal_pan;
    VPoint cam_translate_pan;
    int cam_debug;
    int phys_render;
    
    InputStyle preferred_style;
    void (*change_preferred_style_cb)(struct Input *input,
                                      InputStyle old_style,
                                      InputStyle new_style);
} Input;

Input *Input_create();
void Input_destroy(Input *input);
void Input_poll(Input *input);
void Input_touch(Input *input, Input *touch_input);
void Input_reset(Input *input);
void Input_change_preferred_style(Input *input, InputStyle preferred);

#endif
#ifndef __vrect_h
#define __vrect_h

typedef struct VProjection {
    double min;
    double max;
} VProjection;

int VProjection_does_overlap(VProjection a, VProjection b);
double VProjection_get_overlap(VProjection a, VProjection b);

typedef struct VRectInset {
  double top;
  double right;
  double bottom;
  double left;
} VRectInset;

typedef struct VRect {
    VPoint tl;
    VPoint tr;
    VPoint br;
    VPoint bl;
} VRect;

static const VRect VRectZero = {{0,0},{0,0},{0,0},{0,0}};

VRect VRect_from_xywh(double x, double y, double w, double h);
VRect VRect_inset(VRect rect, VRectInset inset);
VRect VRect_round_out(VRect rect);

VPoint VRect_center(VRect box);
float VRect_width(VRect rect);
float VRect_height(VRect rect);
VPoint VRect_vertex(VRect box, unsigned int index);
void VRect_set_vertex(VRect *box, unsigned int index, VPoint vertex);
VRect VRect_rotate(VRect box, VPoint pivot, double angle_in_rads);
VRect VRect_move(VRect box, VPoint move);
VRect VRect_scale(VRect box, double scale);

VProjection VRect_project_onto(VRect box, VPoint axis);
void VRect_find_axes(VRect box, VPoint *axes);
int VRect_collision(VRect a, VRect b, VPoint *mtv);
VPoint VRect_poc(VRect a, VRect b);
int VRect_contains_point(VRect box, VPoint point);
int VRect_contains_rect(VRect outer, VRect inner);
VRect VRect_bounding_box(VRect rect);
int VRect_is_equal(VRect *a, VRect *b);
VPoint VRect_cnormal_from_mtv(VRect normal_for, VRect against,
        VPoint mtv);

static inline void VRect_debug(VRect rect, char *msg) {
    int i = 0;
    debug("VRect: %s", msg);
    for (i = 0; i < 4; i++) {
        VPoint_debug(VRect_vertex(rect, i), NULL);
    }
    debug("---");
}

#ifdef DABES_SDL
VRect VRect_from_SDL_Rect(SDL_Rect rect);
#endif

VPointRel VPoint_rect_rel(VPoint point, VRect rect);

#endif
#ifndef __vcircle_h
#define __vcircle_h


typedef struct VCircle {
    float radius;
    VPoint center;
} VCircle;

#endif
#ifndef __graphics_h
#define __graphics_h
#include <lcthw/hashmap.h>

#ifdef DABES_SDL
#include <SDL/SDL_ttf.h>
#endif

#include <ft2build.h>
#include FT_FREETYPE_H

extern GLfloat GfxGLClearColor[4];

struct Graphics;

int Graphics_init_GL(int swidth, int sheight);

typedef struct GfxSize {
    double w;
    double h;
} GfxSize;

static const GfxSize GfxSizeZero = {0,0};
VRect VRect_fill_size(GfxSize source_size, GfxSize dest_size);

////////////////////////////////////////////////////////////////////////////////

typedef struct GfxTexture {
    const char *name;
    GfxSize size;
    GfxSize pot_size;
    GLuint gl_tex;
} GfxTexture;

GfxTexture *GfxTexture_from_data(unsigned char **data, int width, int height,
        GLenum source_format);
GfxTexture *GfxTexture_from_image(const char *image_name);
void GfxTexture_destroy(GfxTexture *texture);

////////////////////////////////////////////////////////////////////////////////

typedef enum {
    GfxTextAlignLeft = 0,
    GfxTextAlignRight = 1,
    GfxTextAlignCenter = 2
} GfxTextAlign;

typedef struct GfxFontChar {
    GfxTexture *texture;
    FT_Vector advance;
    float bitmap_top;
} GfxFontChar;

GfxFontChar *GfxFontChar_create(FT_Bitmap *bitmap, FT_Vector advance,
                                float bitmap_top);
void GfxFontChar_destroy(GfxFontChar *fontchar);

typedef struct GfxFont {
    FT_Face face;
    char *name;
    int px_size;
    Hashmap *char_textures;
} GfxFont;

GfxFont *GfxFont_create(struct Graphics *graphics, const char *font_name, int px_size);
void GfxFont_destroy(GfxFont *font);
GfxFontChar *GfxFont_get_char(GfxFont *font, char c, int stroke,
                              struct Graphics *graphics);

////////////////////////////////////////////////////////////////////////////////

enum {
    UNIFORM_DECAL_PROJECTION_MATRIX,
    UNIFORM_DECAL_HAS_TEXTURE,
    UNIFORM_DECAL_TEXTURE,
    UNIFORM_TILEMAP_PROJECTION_MATRIX,
    UNIFORM_TILEMAP_MODELVIEW_MATRIX,
    UNIFORM_TILEMAP_TILE_SIZE,
    UNIFORM_TILEMAP_SHEET_ROWS_COLS,
    UNIFORM_TILEMAP_SHEET_POT_SIZE,
    UNIFORM_TILEMAP_MAP_ROWS_COLS,
    UNIFORM_TILEMAP_ATLAS,
    UNIFORM_TILEMAP_TILESET,
    UNIFORM_PARALLAX_PROJECTION_MATRIX,
    UNIFORM_PARALLAX_MODELVIEW_MATRIX,
    UNIFORM_PARALLAX_TEXTURE,
    UNIFORM_PARALLAX_TEX_PORTION,
    UNIFORM_PARALLAX_REPEAT_SIZE,
    UNIFORM_PARALLAX_REPEATS,
    UNIFORM_PARALLAX_CAMERA_POS,
    UNIFORM_PARALLAX_FACTOR,
    UNIFORM_PARALLAX_TEX_SCALE,
    UNIFORM_TEXT_PROJECTION_MATRIX,
    UNIFORM_TEXT_TEXTURE,
    NUM_UNIFORMS
} UNIFORMS;

enum {
    ATTRIB_DECAL_VERTEX,
    ATTRIB_DECAL_COLOR,
    ATTRIB_DECAL_ALPHA,
    ATTRIB_DECAL_TEXTURE,
    ATTRIB_DECAL_MODELVIEW_MATRIX,
    ATTRIB_TILEMAP_VERTEX,
    ATTRIB_TILEMAP_TEXTURE,
    ATTRIB_PARALLAX_VERTEX,
    ATTRIB_PARALLAX_TEXTURE,
    ATTRIB_TEXT_VERTEX,
    ATTRIB_TEXT_COLOR,
    ATTRIB_TEXT_TEX_POS,
    ATTRIB_TEXT_MODELVIEW_MATRIX,
	NUM_ATTRIBUTES
} ATTRIBS;

enum {
  SAMPLER_TILEMAP_ATLAS,
  SAMPLER_TILEMAP_TILESET,
  NUM_SAMPLERS
} SAMPLERS;

extern GLint GfxShader_uniforms[NUM_UNIFORMS];
extern GLint GfxShader_attributes[NUM_ATTRIBUTES];
extern GLint GfxShader_samplers[NUM_SAMPLERS];

struct Graphics;
struct DrawBuffer;
typedef struct GfxShader {
    void (*set_up)(struct GfxShader *shader, struct Graphics *graphics);
    void (*tear_down)(struct GfxShader *shader, struct Graphics *graphics);
    GLuint gl_program;
    GLuint gl_vertex_array;
    struct DrawBuffer *draw_buffer;
} GfxShader;

void GfxShader_destroy(GfxShader *shader, struct Graphics *graphics);

////////////////////////////////////////////////////////////////////////////////

typedef struct Graphics {
    struct Engine *engine;

    FT_Library ft;

    GfxSize screen_size;
    GfxShader *current_shader;
    GfxFont *debug_font;
    GLuint array_buffer;

    VMatrix projection_matrix;
    VMatrix modelview_matrix;

    Hashmap *textures;
    Hashmap *shaders;
    List *shader_list;
    Hashmap *sprites;

    int gl_vao_enabled;
    void (*gen_vao)(GLsizei n, GLuint *arrays);
    void (*bind_vao)(GLuint array);
    void (*del_vao)(GLsizei n, const GLuint *arrays);
} Graphics;

struct Engine;
Graphics *Graphics_create(struct Engine *engine);
void Graphics_destroy(Graphics *graphics);

void Graphics_stroke_path(Graphics *graphics, VPoint *points, int num_points,
        VPoint center, GLfloat color[4], double line_width, double rotation,
        int loop);
void Graphics_stroke_circle(Graphics *graphics, VCircle circle, int precision,
        VPoint center, GLfloat color[4], double line_width);
void Graphics_stroke_rect(Graphics *graphics, VRect rect, GLfloat color[4],
        double line_width, double rotation);
void Graphics_draw_rect(Graphics *graphics, struct DrawBuffer *draw_buffer,
        VRect rect, GLfloat color[4], GfxTexture *texture, VPoint textureOffset,
        GfxSize textureSize, double rotation, int z_index, GLfloat alpha);
void Graphics_draw_string(Graphics *graphics, char *text, GfxFont *font,
        GLfloat color[4], VPoint origin, GfxTextAlign align,
        GLfloat shadow_color[4], VPoint shadow_offset);

// Projection matrix
void Graphics_reset_projection_matrix(Graphics *graphics);
void Graphics_ortho_projection_matrix(Graphics *graphics, double left,
        double right, double top, double bottom, double near, double far);
void Graphics_perspective_projection_matrix(Graphics *graphics,
                                            float fov_radians, float aspect,
                                            float near, float far);
void Graphics_frustum_projection_matrix(Graphics *graphics, double left,
                                        double right, double top, double bottom, double near, double far);
void Graphics_scale_projection_matrix(Graphics *graphics, double x,
        double y, double z);
void Graphics_rotate_projection_matrix(Graphics *graphics, double rot_degs,
                                       double x, double y, double z);
void Graphics_translate_projection_matrix(Graphics *graphics,
                                         double x, double y, double z);

// Modelview matrix
void Graphics_reset_modelview_matrix(Graphics *graphics);
void Graphics_scale_modelview_matrix(Graphics *graphics,
                                     double x, double y, double z);
void Graphics_rotate_modelview_matrix(Graphics *graphics, double rot_degs,
                                       double x, double y, double z);
void Graphics_translate_modelview_matrix(Graphics *graphics,
                                         double x, double y, double z);

// Shader
GLuint Graphics_load_shader(Graphics *graphics, char *vert_name,
        char *frag_name, GLuint *compiled_program);
GfxShader *Graphics_get_shader(Graphics *graphics, char *name);
void Graphics_use_shader(Graphics *graphics, GfxShader *shader);
int Graphics_init(void *self);
void Graphics_log_shader(GLuint shader);
void Graphics_log_program(GLuint program);

// Textures
GfxTexture *Graphics_texture_from_image(Graphics *graphics, const char *image_name);

// Sprites
struct Sprite;
void Graphics_draw_sprite(Graphics *graphics, struct Sprite *sprite,
                          struct DrawBuffer *draw_buffer, VRect rect,
                          GLfloat color[4], double rot_degs, int z_index,
                          GLfloat alpha);
struct Sprite *Graphics_sprite_from_image(Graphics *graphics, const char *image_name,
    GfxSize cell_size, int padding);

extern Object GraphicsProto;

#endif
#ifndef __stepper_h
#define __stepper_h

typedef struct Stepper {
    float steps_per_second;
    unsigned long stack;

    unsigned long step_skip;
    unsigned long accumulator;
} Stepper;

Stepper *Stepper_create();
void Stepper_destroy(Stepper *stepper);
void Stepper_set_steps_per_second(Stepper *stepper, float steps_per_second);
unsigned long Stepper_update(Stepper *stepper, long unsigned int step_ticks);
int Stepper_reset(Stepper *stepper);
int Stepper_pop(Stepper *stepper);
unsigned long Stepper_clear(Stepper *stepper);

#endif
#ifndef __physics_h
#define __physics_h

typedef struct Physics {
    Stepper *stepper;
} Physics;

Physics *Physics_create();
void Physics_destroy(Physics *physics);

#endif
#ifndef __easer_h
#define __easer_h

// Here are some raw easing functions...

static inline float ease_out_cubic(float time, float start, float change,
                                   float duration) {
	time /= duration;
	time--;
	return change*(time*time*time + 1) + start;
};

////////////////////////////////////////////////////////////////////////////////

typedef float (*Easer_curve)(float progress);

struct Engine;
typedef struct Easer {
    int length_ms;
    int accumulator;
    int finished;
    float time_scale;
    float value;
    Easer_curve curve;
} Easer;

float Easer_curve_linear(float progress);

Easer *Easer_create(int length_ms, Easer_curve curve);
void Easer_destroy(Easer *easer);
void Easer_update(Easer *easer, struct Engine *engine, unsigned long delta_t);

#endif
#ifndef __engine_h
#define __engine_h

#include <sys/time.h>
#include <lcthw/list.h>

typedef struct EngineTimer {
    struct timeval started_at;
    struct timeval paused_at;
    unsigned long pause_skip;
    int paused;
} EngineTimer;

typedef char *(*Engine_resource_path_func)(const char *filename);
typedef struct Engine {
    Audio *audio;
    Console *console;
    Input *input;
    Graphics *graphics;
    Physics *physics;
    Scripting *scripting;

    List *easers;

    Engine_resource_path_func resource_path;
    Engine_resource_path_func project_path;
    EngineTimer timer;

    short int reg_initialized;
    short int frame_now;
    long unsigned int frame_ticks;
    long unsigned int frame_skip;
    long unsigned int last_frame_at;
} Engine;

Engine *Engine_create(Engine_resource_path_func path_func,
                      Engine_resource_path_func project_path_func,
                      ConsoleProto console_proto,
                      const char *boot_script, void **sdl_screen);
void Engine_set_resource_path(Engine *engine,
                              Engine_resource_path_func resource_path);
void Engine_set_project_path(Engine *engine,
                             Engine_resource_path_func project_path);
void Engine_destroy(Engine *engine);
int Engine_bootstrap(Engine **engine, void **sdl_screen);
void Engine_regulate(Engine *engine);

void Engine_pause_time(Engine *engine);
void Engine_resume_time(Engine *engine);
unsigned long Engine_get_ticks(Engine *engine);

struct Scene;
struct Scene *Engine_get_current_scene(Engine *engine);
void Engine_frame_end(Engine *engine);

Easer *Engine_gen_easer(Engine *engine, int length_ms, Easer_curve curve);
void Engine_update_easers(Engine *engine);

FILE *Engine_open_resource(Engine *engine, char *filename);
int Engine_load_resource(Engine *engine, char *filename, unsigned char **out,
                         GLint *size);

#ifdef DABES_IOS
#define Engine_log(A, ...) Engine_log_iOS(A, ##__VA_ARGS__)
void Engine_log_iOS(char *fmt, ...);
#else
#define Engine_log(A, ...) debug(A, ##__VA_ARGS__)
#endif

#endif
#ifndef __console_bindings_h
#define __console_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Console_lib;

int luaopen_dabes_console(lua_State *L);

#endif
#ifndef __easer_bindings_h
#define __easer_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Easer_lib;
extern const char *luab_Easer_metatable;
typedef Scripting_userdata_for(Easer) Easer_userdata;
Scripting_caster_for(Easer, luaL_toeaser);

int luaopen_dabes_easer(lua_State *L);

#endif
#ifndef __engine_bindings_h
#define __engine_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Engine_lib;

int luaopen_dabes_engine(lua_State *L);

#endif

#ifndef __gzip_h
#define __gzip_h

unsigned long int decompress_data(unsigned char* abSrc, unsigned long nLenSrc, unsigned char** abDst, int nLenDst);
  
#endif
#ifndef __fixture_h
#define __fixture_h

typedef struct Fixture {
    Object proto;
    void *world;
    double time_scale;

    VPoint center;
    double width;
    double height;

    double restitution;
    double mass;
    double drag;
    double surface_area;

    double rotation_radians;
    double angular_velocity;
    double angular_acceleration;
    double moment_of_inertia;

    VPoint velocity;
    VPoint acceleration;

    double step_dt;
    VPoint step_force;
    double step_torque;
    VPoint step_displacement;
    VPoint step_velocity;
    VPoint step_acceleration;
    double step_rotation;
    double step_angular_velocity;
    double step_angular_acceleration;

    Controller *controller;
    VPoint input_acceleration;

    int on_ground;
    int moving;
    int colliding;

    VRect history[FIXTURE_HISTORY_LENGTH];
    List *collisions;
    List *walls;
} Fixture;

int Fixture_init(void *self);
void Fixture_destroy(void *self);
void Fixture_set_rotation_degrees(Fixture *fixture, double degrees);
void Fixture_set_wh(Fixture *fixture, double w, double h);
void Fixture_set_mass(Fixture *fixture, double m);
double Fixture_rotation_degrees(Fixture *fixture);
VRect Fixture_base_box(Fixture *fixture);
VRect Fixture_real_box(Fixture *fixture);
VRect Fixture_display_rect(Fixture *fixture);
VPoint Fixture_display_center(Fixture *fixture);

void Fixture_step_reset(Physics *physics, Fixture *fixture, double advance_ms);
void Fixture_step_displace(Physics *physics, Fixture *fixture);
void Fixture_step_apply_environment(Physics *physics, Fixture *fixture);
void Fixture_step_apply_forces(Physics *physics, Fixture *fixture);
void Fixture_step_control(Fixture *fixture, Controller *controller);
void Fixture_step_commit(Physics *physics, Fixture *fixture);

extern Object FixtureProto;

typedef struct FixtureCollision {
    VPoint poc;
    VPoint collision_normal;
    VPoint mtv;
    Fixture *collider;
} FixtureCollision;

#endif
#ifndef __body_h
#define __body_h
#include <chipmunk/chipmunk.h>
#include <lcthw/list.h>

struct Entity;
struct Engine;
struct Scene;
typedef struct {
  struct Engine *engine;
  struct Entity *entity;
  struct Scene *scene;
  int on_ground;
} BodyStateData;

struct Body;
struct Sensor;
typedef struct BodyProto {
    int (*init)(struct Body *body, float w, float h, float mass,
            int can_rotate);
    void (*cleanup)(struct Body *body);

    VRect (*gfx_rect)(struct Body *body, float pixels_per_meter, int rotate);
    VPoint (*gfx_center)(struct Body *body, float pixels_per_meter);

    void (*add_sensor)(struct Body *body, struct Sensor *sensor);
    void (*remove_sensor)(struct Body *body, struct Sensor *sensor);

    void (*apply_force)(struct Body *body, VPoint force, VPoint offset);
    void (*set_hit_box)(struct Body *body, float w, float h, VPoint offset);

    VPoint (*get_pos)(struct Body *body);
    void (*set_pos)(struct Body *body, VPoint pos);
    VPoint (*get_velo)(struct Body *body);
    void (*set_velo)(struct Body *body, VPoint velo);
    VPoint (*get_force)(struct Body *body);
    void (*set_force)(struct Body *body, VPoint force);
    float (*get_angle)(struct Body *body);
    void (*set_angle)(struct Body *body, float angle);
    float (*get_friction)(struct Body *body);
    void (*set_friction)(struct Body *body, float friction);
    float (*get_elasticity)(struct Body *body);
    void (*set_elasticity)(struct Body *body, float elasticity);
    float (*get_mass)(struct Body *body);
    void (*set_mass)(struct Body *body, float mass);
    int (*get_can_rotate)(struct Body *body);
    void (*set_can_rotate)(struct Body *body, int can_rotate);
    int (*get_is_rogue)(struct Body *body);
    void (*set_is_rogue)(struct Body *body, int is_rogue);
    int (*get_is_static)(struct Body *body);
    void (*set_is_static)(struct Body *body, int is_static);
} BodyProto;

typedef struct Body {
    BodyProto proto;
    BodyStateData state;

    Fixture *fixture;

    cpSpace *cp_space;
    cpShape *cp_shape;
    cpBody *cp_body;

    int is_rogue;
    int is_static;
    int can_rotate;
    float mass;
    float w;
    float h;

    VPoint draw_offset;

    void *context;
  
    List *sensors;
} Body;

Body *Body_create(BodyProto proto, float w, float h, float mass,
        int can_rotate);
void Body_destroy(Body *body);
void Body_add_sensor(Body *body, struct Sensor *sensor);
void Body_remove_sensor(Body *body, struct Sensor *sensor);

#endif
#ifndef __body_bindings_h
#define __body_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Body_lib;
extern const char *luab_Body_metatable;
typedef Scripting_userdata_for(Body) Body_userdata;
Scripting_caster_for(Body, luaL_tobody);

int luaopen_dabes_body(lua_State *L);

#endif
#ifndef __chipmunk_body_h
#define __chipmunk_body_h

extern BodyProto ChipmunkBodyProto;

#endif
#ifndef __sprite_h
#define __sprite_h
#include <lcthw/hashmap.h>

typedef struct SpriteFrame {
    VPoint offset;
} SpriteFrame;

typedef struct SpriteAnimation {
    int num_frames;
    int loop_start;
    int current_index;
    int repeats;
    Stepper *stepper;
    int frames[];
} SpriteAnimation;

SpriteAnimation *SpriteAnimation_create(int num_frames, int frames[]);
void SpriteAnimation_destroy(SpriteAnimation *animation);

////////////////////////////////////////////////////////////////////////////////

typedef enum {
    SPRITE_DIR_FACING_RIGHT = 0,
    SPRITE_DIR_FACING_LEFT  = 180
} SpriteDirection;

typedef struct Sprite {
    GfxTexture *texture;
    GfxSize cell_size;
    int padding;
    int rows;
    int cols;
    int num_frames;

    Hashmap *animations;
    SpriteAnimation *current_animation;
    short int manual_frames;

    SpriteDirection direction;
    int current_frame;
    SpriteFrame frames[];
} Sprite;

Sprite *Sprite_create(GfxTexture *texture, GfxSize cell_size, int padding);
void Sprite_destroy(Sprite *sprite);
void Sprite_update(Sprite *sprite, Engine *engine);

int Sprite_add_animation(Sprite *sprite, SpriteAnimation *animation,
        const char *name);
int Sprite_use_animation(Sprite *sprite, const char *name);

void SpriteAnimation_update(SpriteAnimation *animation, Engine *engine);

#endif
#ifndef __entity_h
#define __entity_h
#include <chipmunk/chipmunk.h>

typedef enum {
    EntityPhysicsShapeTypeFixture = 0,
    EntityPhysicsShapeTypeCPShape
} EntityPhysicsShapeType;

struct Scene;
typedef struct Entity {
    Controller *controller;
    short int auto_control;
    short int force_keyframe;

    Sprite *sprite;
    Body *body;
    struct Scene *scene;
    VVector4 bg_color;
    GLfloat alpha;

    int pixels_per_meter;

    uint16_t z_index;
    uint32_t timestamp;
    uint16_t add_index;

    uint64_t z_key;

    VPoint center;
    GfxSize size;

    int selected;
} Entity;

struct Engine;
struct DrawBuffer;

Entity *Entity_create(struct Engine *engine);
void Entity_destroy(Entity *entity);
void Entity_render(Entity *self, struct Engine *engine,
                   struct DrawBuffer *draw_buffer);
void Entity_assign_controller(Entity *entity, Controller *controller);
void Entity_update(Entity *entity, struct Engine *engine);
VPoint Entity_center(Entity *entity);
VRect Entity_real_rect(Entity *entity);
VRect Entity_bounding_rect(Entity *entity);
void Entity_set_z_index(Entity *entity, uint16_t z_index);
void Entity_set_add_index(Entity *entity, uint16_t add_index);
int Entity_z_cmp(void *a, void *b);

int Entity_set_center(Entity *entity, VPoint center);
int Entity_set_size(Entity *entity, GfxSize size);

#endif
#ifndef __entity_bindings_h
#define __entity_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Entity_lib;
extern const char *luab_Entity_metatable;
typedef Scripting_userdata_for(Entity) Entity_userdata;
Scripting_caster_for(Entity, luaL_toentity);

int luaopen_dabes_entity(lua_State *L);

#endif
#ifndef __sensor_h
#define __sensor_h
#include <chipmunk/chipmunk.h>
#include <lcthw/list.h>

typedef struct Sensor {
    Body *body;

    float w;
    float h;
    VPoint offset;

    cpSpace *cp_space;
    cpShape *cp_shape;

    int on_static;
    List *on_sensors;
} Sensor;

Sensor *Sensor_create(float w, float h, VPoint offset);
void Sensor_destroy();
void Sensor_overlap_sensor(Sensor *a, Sensor *b);
void Sensor_separate_sensor(Sensor *a, Sensor *b);

#endif
#ifndef __sensor_bindings_h
#define __sensor_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Sensor_lib;
extern const char *luab_Sensor_metatable;
typedef Scripting_userdata_for(Sensor) Sensor_userdata;
Scripting_caster_for(Sensor, luaL_tosensor);

int luaopen_dabes_sensor(lua_State *L);

#endif
#ifndef __camera_h
#define __camera_h

struct Entity;
typedef struct Camera {
    VPoint focal;
    struct GfxSize screen_size;
  
    int has_scene_size;
    struct GfxSize scene_size;

    int num_entities;
    struct Entity **track_entities;

    int snap_to_scene;
    double max_scale;
    double min_scale;

    VRectInset margin;
    double scale;
    double rotation_radians;
    VPoint translation;
} Camera;

Camera *Camera_create(int width, int height);
void Camera_set_scene_size(Camera *camera, GfxSize scene_size);
void Camera_track_entities(Camera *camera, int num_entities,
        struct Entity **entities);
void Camera_track(Camera *camera);
void Camera_destroy(Camera *camera);
void Graphics_project_camera(Graphics *graphics, Camera *camera);
void Graphics_project_screen_camera(Graphics *graphics, Camera *camera);
VRect Camera_base_rect(Camera *camera);
VRect Camera_visible_rect(Camera *camera);
VRect Camera_tracking_rect(Camera *camera);
VRect Camera_project_rect(Camera *camera, VRect rect, int translation);
void Camera_debug(Camera *camera, Graphics *graphics);

// World point -> screen point
VPoint Camera_project_point(Camera *camera, VPoint point, int translation);

// Screen point -> world point
VPoint Camera_cast_point(Camera *camera, VPoint point);

#endif
#ifndef __camera_bindings_h
#define __camera_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Camera_lib;
extern const char *luab_Camera_metatable;
typedef Scripting_userdata_for(Camera) Camera_userdata;
Scripting_caster_for(Camera, luaL_tocamera);

int luaopen_dabes_camera(lua_State *L);

#endif
#ifndef __draw_buffer_h
#define __draw_buffer_h
#include <lcthw/bstrlib.h>
#include <lcthw/darray.h>
#include <lcthw/hashmap.h>
#include <lcthw/hashmap_algos.h>
#include <lcthw/list.h>

typedef struct DrawBufferShape {
    int num_points;
    int num_vectors;
    VMatrix vectors[];
} DrawBufferShape;

typedef struct DrawBufferTexture {
    GfxTexture *texture;
    bstring key;
} DrawBufferTexture;

typedef struct DrawBufferLayer {
    int z_index;
    DArray *textures;
    Hashmap *texture_buffers;
} DrawBufferLayer;

DrawBufferLayer *DrawBufferLayer_create(int z_index);
void DrawBufferLayer_buffer(DrawBufferLayer *layer, GfxTexture *texture,
                            int num_points, int num_attrs, VVector4 vectors[]);
void DrawBufferLayer_destroy(DrawBufferLayer *layer);
void DrawBufferLayer_draw(DrawBufferLayer *layer);

typedef struct DrawBuffer {
    List *layers;
} DrawBuffer;

DrawBuffer *DrawBuffer_create();
void DrawBuffer_destroy(DrawBuffer *buffer);
void DrawBuffer_buffer(DrawBuffer *buffer, GfxTexture *texture, int z_index,
                       int num_points, int num_attrs, VVector4 vectors[]);
void DrawBuffer_empty(DrawBuffer *buffer);
void DrawBuffer_draw(DrawBuffer *buffer);

#endif
#ifndef __parallax_h
#define __parallax_h
#include <lcthw/darray.h>

typedef struct ParallaxLayer {
    GfxTexture *texture;
    VPoint offset;
    double scale;
    double p_factor;
    double y_wiggle;
} ParallaxLayer;

ParallaxLayer *ParallaxLayer_create(GfxTexture *tex);

typedef struct Parallax {
    DArray *layers;
    Camera *camera;
    GfxSize level_size;
    VVector4 sky_color;
    VVector4 sea_color;
    double y_wiggle;
    double sea_level;
} Parallax;

Parallax *Parallax_create();
void Parallax_destroy(Parallax *parallax);
int Parallax_add_layer(Parallax *parallax, ParallaxLayer *layer);
void Parallax_render(Parallax *parallax, Graphics *graphics);

#endif
#ifndef __parallax_bindings_h
#define __parallax_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_ParallaxLayer_lib;
extern const char *luab_ParallaxLayer_metatable;
typedef Scripting_userdata_for(ParallaxLayer) ParallaxLayer_userdata;
Scripting_caster_for(ParallaxLayer, luaL_toparallaxlayer);

extern const char *luab_Parallax_lib;
extern const char *luab_Parallax_metatable;
typedef Scripting_userdata_for(Parallax) Parallax_userdata;
Scripting_caster_for(Parallax, luaL_toparallax);

int luaopen_dabes_parallax(lua_State *L);

#endif
#ifndef __sprite_bindings_h
#define __sprite_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_SpriteAnimation_lib;
extern const char *luab_SpriteAnimation_metatable;
typedef Scripting_userdata_for(SpriteAnimation) SpriteAnimation_userdata;
Scripting_caster_for(SpriteAnimation, luaL_tospriteanimation);

extern const char *luab_Sprite_lib;
extern const char *luab_Sprite_metatable;
typedef Scripting_userdata_for(Sprite) Sprite_userdata;
Scripting_caster_for(Sprite, luaL_tosprite);

int luaopen_dabes_sprite(lua_State *L);

#endif
#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// To get a header file for this, either cut and paste the header,
// or create stb_image.h, #define STBI_HEADER_FILE_ONLY, and
// then include stb_image.c from it.

////   begin header file  ////////////////////////////////////////////////////
//
// Limitations:
//    - no jpeg progressive support
//    - non-HDR formats support 8-bit samples only (jpeg, png)
//    - no delayed line count (jpeg) -- IJG doesn't support either
//    - no 1-bit BMP
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x       -- outputs image width in pixels
//    int *y       -- outputs image height in pixels
//    int *comp    -- outputs # of image components in image file
//    int req_comp -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to easily see if it's opaque.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB; nominally they
// would silently load as BGR, except the existing code should have just
// failed on such iPhone PNGs. But you can disable this conversion by
// by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through.
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).


#ifndef STBI_NO_STDIO

#if defined(_MSC_VER) && _MSC_VER >= 0x1400
#define _CRT_SECURE_NO_WARNINGS // suppress bogus warnings about fopen()
#endif

#include <stdio.h>
#endif

#define STBI_VERSION 1

enum
{
  STBI_default = 0, // only used for req_comp
  
  STBI_grey       = 1,
  STBI_grey_alpha = 2,
  STBI_rgb        = 3,
  STBI_rgb_alpha  = 4
};

typedef unsigned char stbi_uc;

#ifdef __cplusplus
extern "C" {
#endif
  
  //////////////////////////////////////////////////////////////////////////////
  //
  // PRIMARY API - works on images of any type
  //
  
  //
  // load image by filename, open file, or memory buffer
  //
  
  extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
  
#ifndef STBI_NO_STDIO
  extern stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
  extern stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
  // for stbi_load_from_file, file pointer is left pointing immediately after image
#endif
  
  typedef struct
  {
    int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
    void     (*skip)  (void *user,unsigned n);            // skip the next 'n' bytes
    int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
  } stbi_io_callbacks;
  
  extern stbi_uc *stbi_load_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
  
#ifndef STBI_NO_HDR
  extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
  
#ifndef STBI_NO_STDIO
  extern float *stbi_loadf            (char const *filename,   int *x, int *y, int *comp, int req_comp);
  extern float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);
#endif
  
  extern float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
  
  extern void   stbi_hdr_to_ldr_gamma(float gamma);
  extern void   stbi_hdr_to_ldr_scale(float scale);
  
  extern void   stbi_ldr_to_hdr_gamma(float gamma);
  extern void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_HDR
  
  // stbi_is_hdr is always defined
  extern int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
  extern int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
  extern int      stbi_is_hdr          (char const *filename);
  extern int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO
  
  
  // get a VERY brief reason for failure
  // NOT THREADSAFE
  extern const char *stbi_failure_reason  (void);
  
  // free the loaded image -- this is just free()
  extern void     stbi_image_free      (void *retval_from_stbi_load);
  
  // get image dimensions & components without fully decoding
  extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
  extern int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
  
#ifndef STBI_NO_STDIO
  extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
  extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
  
#endif
  
  
  
  // for image formats that explicitly notate that they have premultiplied alpha,
  // we just return the colors as stored in the file. set this flag to force
  // unpremultiplication. results are undefined if the unpremultiply overflow.
  extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
  
  // indicate whether we should process iphone images back to canonical format,
  // or just pass them through "as-is"
  extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
  
  
  // ZLIB client - used by PNG, available for other purposes
  
  extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
  extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
  extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
  
  extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
  extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
  
  
  // define faster low-level operations (typically SIMD support)
#ifdef STBI_SIMD
  typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);
  // compute an integer IDCT on "input"
  //     input[x] = data[x] * dequantize[x]
  //     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'
  //                             CLAMP results to 0..255
  typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);
  // compute a conversion from YCbCr to RGB
  //     'count' pixels
  //     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B
  //     y: Y input channel
  //     cb: Cb input channel; scale/biased to be 0..255
  //     cr: Cr input channel; scale/biased to be 0..255
  
  extern void stbi_install_idct(stbi_idct_8x8 func);
  extern void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);
#endif // STBI_SIMD
  
  
#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifndef __tile_map_h
#define __tile_map_h
#include <lcthw/hashmap.h>
#include <lcthw/darray.h>

//TODO: objectgroup
//TODO: properties

extern const unsigned FLIPPED_HORIZONTALLY_FLAG;
extern const unsigned FLIPPED_VERTICALLY_FLAG;
extern const unsigned FLIPPED_DIAGONALLY_FLAG;

// Only PNG
// Doesn't support: format, trans
typedef struct Tileset {
    int spacing;
    int margin;
    GfxSize tile_size;
    uint32_t first_gid;
    char *name;
    char *img_src;
    GfxTexture *texture;
} Tileset;

void Tileset_destroy(Tileset *tileset);

typedef struct TilesetTile {
  uint32_t gid;
  Tileset *tileset;
  VPoint tl;
  GfxSize size;
} TilesetTile;

typedef struct TileMapLayer {
    char *name;
    double opacity;
    int visible;
    int gid_count;
    uint32_t *tile_gids;
    GfxTexture *atlas;
    uint8_t *raw_atlas;
    Tileset *tileset;
} TileMapLayer;

TileMapLayer *TileMapLayer_create();
void TileMapLayer_destroy(TileMapLayer *layer);

// Only orthogonal
typedef struct TileMap {
  int rows;
  int cols;
  GfxSize tile_size;
  DArray *tilesets;
  DArray *layers;
  DArray *collision_shapes;
  float meters_per_tile;
} TileMap;

TileMap *TileMap_create();
void TileMap_destroy(TileMap *map);
void TileMap_render(TileMap *map, Graphics *graphics, int pixels_per_meter);
TilesetTile *TileMap_resolve_tile_gid(TileMap *map, uint32_t gid);
GfxSize TileMap_draw_size(TileMap *map, int pixels_per_meter);

void TileMapLayer_draw(TileMapLayer *layer, TileMap *map, Graphics *graphics);

#endif
#ifndef __tile_map_parse_h
#define __tile_map_parse_h

typedef enum {
  TILEMAP_PARSE_OK = 0,
  TILEMAP_PARSE_INVALID_FORMAT = 1,
  TILEMAP_PARSE_INVALID_ORIENTATION = 2,
  TILEMAP_PARSE_MISSING_IMAGE = 3,
  TILEMAP_PARSE_UNKNOWN_ERR = 4
} TileMapParseStatus;

TileMap *TileMap_parse(char *filename, Engine *engine);

#endif
#ifndef __controller_bindings_h
#define __controller_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Controller_lib;
extern const char *luab_Controller_metatable;
typedef Scripting_userdata_for(Controller) Controller_userdata;
Scripting_caster_for(Controller, luaL_tocontroller);

int luaopen_dabes_controller(lua_State *L);

#endif
#ifndef __shape_matcher_h
#define __shape_matcher_h
#include <lcthw/darray.h>
#include <lcthw/bstree.h>
#include <lcthw/hashmap.h>

typedef struct ShapeSegment {
    float length;
    float angle_degrees;
} ShapeSegment;

ShapeSegment ShapeSegment_make(float length, float angle_degrees);

////////////////////////////////////////////////////////////////////////////////

typedef enum {
    SHAPE_WINDING_COUNTERCLOCKWISE = 1,
    SHAPE_WINDING_AMBIGUOUS = 0,
    SHAPE_WINDING_CLOCKWISE = -1
} ShapeWinding;

typedef struct Shape {
    ShapeSegment *segments;
    int num_segments;
    char *name;
} Shape;

Shape *Shape_create(ShapeSegment *segments, int num_segments, const char *name);
void Shape_destroy(Shape *shape);
VPath *Shape_get_path(Shape *shape, VPoint start_point, float initial_length,
    float initial_angle_degrees, ShapeWinding winding, VPoint *farthest_point);

////////////////////////////////////////////////////////////////////////////////

typedef struct MatchedPoint {
    int index;
    float distance;
} MatchedPoint;

typedef struct PotentialShape {
    Shape *shape;
    DArray *matched_points;
    VPath *path;
    VPoint farthest;
} PotentialShape;

PotentialShape *PotentialShape_create(Shape *shape);
void PotentialShape_destroy(PotentialShape *pshape);

////////////////////////////////////////////////////////////////////////////////

extern const float SHAPE_MATCHER_DEFAULT_VERTEX_CATCH;
extern const float SHAPE_MATCHER_DEFAULT_SLOP;

typedef enum {
    SHAPE_MATCHER_STATE_NEW = 0,
    SHAPE_MATCHER_STATE_RUNNING = 1,
    SHAPE_MATCHER_STATE_ENDED = 2
} ShapeMatcherState;

typedef struct ShapeMatcher {
    DArray *shapes;
    int num_shapes;
    ShapeMatcherState state;

    float vertex_catch_tolerance;
    float slop_tolerance;

    float initial_segment_angle;
    float initial_segment_length;
    ShapeWinding intended_convex_winding;

    DArray *points;
    VPoint *staged_point;
    BSTree *potential_shapes;
    DArray *marked_shape_keys;

    PotentialShape *matched_shape;

    int debug_shapes;
    VVector4 debug_shape_color;
    int debug_shape_width;

    VVector4 dot_color;
    int dot_width;
} ShapeMatcher;

struct Engine;

ShapeMatcher *ShapeMatcher_create(Shape *shapes[], int num_shapes);
void ShapeMatcher_destroy(ShapeMatcher *matcher);
void ShapeMatcher_reset(ShapeMatcher *matcher, struct Engine *engine);
int ShapeMatcher_start(ShapeMatcher *matcher, VPoint point,
                       struct Engine *engine);
int ShapeMatcher_stage_point(ShapeMatcher *matcher, VPoint point);
int ShapeMatcher_commit_point(ShapeMatcher *matcher, struct Engine *engine);
int ShapeMatcher_end(ShapeMatcher *matcher, struct Engine *engine);
void ShapeMatcher_get_potential_shape_paths(ShapeMatcher *matcher,
    VPath ***paths, int *num_paths);
void ShapeMatcher_get_connect_dots(ShapeMatcher *matcher, VCircle **circles,
    int *num_circles);

#endif
#ifndef __canvas_h
#define __canvas_h
#include <lcthw/darray.h>

struct Scene;

#define CANVAS_QUEUE_SIZE 128

typedef struct Canvas {
    DArray *raw_points;
    DArray *simplified_points;

    int enabled;
    float alpha;
    VPoint offset;

    struct Scene *scene;

    float angle_threshold;
    float distance_threshold;
    float draw_width;

    VVector4 bg_color;
    VVector4 draw_color;
    VVector4 simplified_path_color;
    VVector4 angle_color;

    VPoint point_queue[CANVAS_QUEUE_SIZE];
    int queue_count;

    VPoint *staged_point;

    ShapeMatcher *shape_matcher;
} Canvas;

Canvas *Canvas_create(Engine *engine);
void Canvas_destroy(Canvas *canvas);
void Canvas_empty(Canvas *canvas);
void Canvas_enqueue_point(Canvas *canvas, VPoint point);
void Canvas_update(Canvas *canvas, Engine *engine);
void Canvas_render(Canvas *canvas, Engine *engine);
void Canvas_set_enabled(Canvas *canvas, Engine *engine, int enabled);

#endif
#ifndef __canvas_bindings_h
#define __canvas_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Canvas_lib;
extern const char *luab_Canvas_metatable;
typedef Scripting_userdata_for(Canvas) Canvas_userdata;
Scripting_caster_for(Canvas, luaL_tocanvas);

int luaopen_dabes_canvas(lua_State *L);


#endif
#ifndef __physics_world_grid_h
#define __physics_world_grid_h

typedef enum {
    WORLDGRIDMEMBER_FIXTURE,
    WORLDGRIDMEMBER_TILE
} WorldGridMemberType;

typedef struct {
    WorldGridMemberType member_type;
    union {
        Fixture *fixture;
        void *raw;
    };
} WorldGridMember;

int WorldGridMember_is_equal(WorldGridMember *a, WorldGridMember *b);

typedef struct WorldGridPoint {
    WorldGridMember owner;
    VPoint point;
} WorldGridPoint;

WorldGridPoint *WorldGridPoint_create(VPoint point, WorldGridMember owner);
void WorldGridPoint_destroy(WorldGridPoint *wgpoint);
int WorldGridPoint_is(WorldGridPoint *wgpoint, VPoint point,
        WorldGridMember owner);

typedef struct WorldGridCell {
    int row;
    int col;
    List *points;
} WorldGridCell;

WorldGridCell *WorldGridCell_create(int row, int col);
void WorldGridCell_destroy(WorldGridCell *cell);

typedef struct WorldGrid {
    int rows;
    int cols;
    double grid_size;
    DArray *cells;
} WorldGrid;

WorldGrid *WorldGrid_create(int rows, int cols, double grid_size);
void WorldGrid_destroy(WorldGrid *grid);

int WorldGrid_update_fixture(WorldGrid *grid, Fixture *fixture);

int WorldGrid_add_fixture(WorldGrid *grid, Fixture *fixture);
int WorldGrid_add_box(WorldGrid *grid, VRect box, WorldGridMember owner);
int WorldGrid_add_point(WorldGrid *grid, VPoint point,
        WorldGridMember owner);

int WorldGrid_remove_fixture(WorldGrid *grid, Fixture *fixture);
int WorldGrid_remove_box(WorldGrid *grid, VRect box, WorldGridMember owner);
int WorldGrid_remove_point(WorldGrid *grid, VPoint point,
        WorldGridMember owner);

WorldGridCell *WorldGrid_cell_for_point(WorldGrid *grid, VPoint point);
List *WorldGrid_cells_for_box(WorldGrid *grid, VRect box);
List *WorldGrid_members_near_fixture(WorldGrid *grid, Fixture *fixture);
VRect WorldGrid_box_for_cell(WorldGrid *grid, int col, int row);

#endif
#ifndef __world_h
#define __world_h

struct World {
    double height;
    double width;
    double grid_size;
    double time_scale;
    double pixels_per_meter;
    double gravity;
    double air_density;
    uint num_fixtures;
    List *fixtures;
    WorldGrid *grid;
};
typedef struct World World;

World *World_create(int cols, int rows);
void World_destroy(World *world);
void World_solve(Physics *physics, World *world, TileMap *tile_map,
                 double advance_ms);
Fixture *World_create_fixture(World *world);
VRect World_floor_box(World *world);
VRect World_ceil_box(World *world);
VRect World_left_wall_box(World *world);
VRect World_right_wall_box(World *world);

#endif
#ifndef __recorder_h
#define __recorder_h
#include <lcthw/darray.h>

struct Recorder;
typedef struct RecorderProto {
    void *(*capture_frame)(struct Recorder *recorder, size_t *size);
    void (*apply_frame)(struct Recorder *recorder, void *frame);
    void (*clear_frames)(struct Recorder *recorder);
    void (*rewind)(struct Recorder *recorder);
    void (*start_play_cb)(struct Recorder *recorder);
    void (*stop_play_cb)(struct Recorder *recorder);
    void (*pack)(struct Recorder *recorder, unsigned char **buffer,
                 size_t *size);
    void (*unpack)(struct Recorder *recorder, unsigned char *buffer,
                   size_t size);
} RecorderProto;

typedef enum {
    RecorderStateIdle = 0,
    RecorderStateRecording = 1,
    RecorderStatePlaying = 2
} RecorderState;

typedef struct Recorder {
    RecorderProto proto;
    Entity *entity;
    DArray *frames;

    void *context;
    char *id;

    int current_frame;
    RecorderState state;

    int num_frames;
    double avg_frame_size;
    size_t total_frame_size;
} Recorder;

Recorder *Recorder_create(int preroll_ms, int fps);
void Recorder_destroy(Recorder *recorder);
void Recorder_write_frame(Recorder *recorder, void *frame, size_t size);
void *Recorder_read_frame(Recorder *recorder);
void Recorder_set_state(Recorder *recorder, RecorderState state);

#endif
#ifndef __scene_h
#define __scene_h
#include <chipmunk/chipmunk.h>
#include <lcthw/bstree.h>
#include <lcthw/darray.h>

typedef enum {
    kSceneKindStatic = 0,
    kSceneKindChipmunk = 1
} SceneKind;

struct Scene;
typedef struct SceneProto {
    SceneKind kind;
    void (*start)(struct Scene *scene, Engine *engine);
    void (*start_success_cb)(struct Scene *scene, Engine *engine);
    void (*stop)(struct Scene *scene, Engine *engine);
    void (*cleanup)(struct Scene *scene, Engine *engine);
    void (*update)(struct Scene *scene, Engine *engine);
    void (*render)(struct Scene *scene, Engine *engine);
    void (*control)(struct Scene *scene, Engine *engine);
    void (*add_entity_cb)(struct Scene *scene, Engine *engine, Entity *entity);
    void (*remove_entity_cb)(struct Scene *scene, Engine *engine, Entity *entity);
    void (*add_recorder)(struct Scene *scene, Engine *engine, Recorder *recorder);
    void (*remove_recorder)(struct Scene *scene, Engine *engine, Recorder *recorder);
    Entity *(*hit_test)(struct Scene *scene, VPoint g_point);
    VPoint (*get_gravity)(struct Scene *scene);
    void (*set_gravity)(struct Scene *scene, VPoint gravity);
} SceneProto;

typedef enum {
  kSceneRenderModeNormal = 0,
  kSceneRenderModePhysicsDebug = 1
} SceneRenderMode;

typedef enum {
  kSceneNotSelecting = 0,
  kSceneSelectingForCamera = 1,
  kSceneSelectingForRecorder = 2
} SceneEntitySelectionMode;

typedef struct Scene {
    SceneProto proto;
    void *context;
    char *name;

    GfxTexture *bg_texture; // deprecated

    BSTree *entities;
    BSTree *overlays;
    uint16_t entity_count;
    uint16_t overlay_count;

    Music *music;
    Camera *camera;
    union {
      World *world;
      cpSpace *space;
    };
    Parallax *parallax;
    TileMap *tile_map;
    Canvas *canvas;

    VVector4 bg_color;
    VVector4 cover_color;

    short int draw_debug_text;
    short int draw_grid;
    short int debug_camera;
    short int render_mode;
    int started;
    long int started_at;

    int pixels_per_meter;
    VPoint gravity;

    SceneEntitySelectionMode selection_mode;
    List *selected_entities;
} Scene;

Scene *Scene_create(Engine *engine, SceneProto proto);
void Scene_destroy(Scene *scene, Engine *engine);
void Scene_restart(Scene *scene, Engine *engine);
void Scene_load_tile_map(Scene *scene, Engine *engine, char *map_file,
                         int abs_path, float meters_per_tile);
void Scene_set_tile_map(Scene *scene, Engine *engine, TileMap *tile_map);
void Scene_set_music(Scene *scene, Music *music);
void Scene_draw_debug_grid(Scene *scene, Graphics *graphics);
void Scene_reset_camera(Scene *scene, Engine *engine);
void Scene_render(Scene *scene, Engine *engine);
void Scene_update(Scene *scene, Engine *engine);
void Scene_control(Scene *scene, Engine *engine);
void Scene_start(Scene *scene, Engine *engine);
void Scene_stop(Scene *scene, Engine *engine);

void Scene_set_selection_mode(Scene *scene, SceneEntitySelectionMode mode);
int Scene_select_entities_at(Scene *scene, VPoint screen_point);

// Rendering
void Scene_project_screen(Scene *scene, Engine *engine);
void Scene_fill(Scene *scene, Engine *engine, VVector4 color);
void Scene_render_entities(Scene *scene, Engine *engine);
void Scene_render_selected_entities(Scene *scene, Engine *engine);
void Scene_render_overlays(Scene *scene, Engine *engine);

struct Overlay;
void Scene_add_entity(Scene *scene, Engine *engine, struct Entity *entity);
void Scene_remove_entity(Scene *scene, Engine *engine, struct Entity *entity);

void Scene_add_overlay(Scene *scene, struct Overlay *overlay);
void Scene_remove_overlay(Scene *scene, struct Overlay *overlay);


#endif
#ifndef __overlay_h
#define __overlay_h

struct Sprite;

typedef struct Overlay {
    Scene *scene;
    GfxFont *font;
    DArray *sprites;
    Entity *track_entity;
  
    float alpha;
  
    uint16_t z_index;
    uint32_t timestamp;
    uint16_t add_index;

    uint64_t z_key;
} Overlay;

Overlay *Overlay_create(Engine *engine, char *font_name, int px_size);
void Overlay_destroy(Overlay *overlay);
void Overlay_update(Overlay *overlay, Engine *engine);
void Overlay_render(Overlay *overlay, Engine *engine);
void Overlay_add_sprite(Overlay *overlay, struct Sprite *sprite);
void Overlay_set_z_index(Overlay *overlay, uint16_t z_index);
void Overlay_set_add_index(Overlay *overlay, uint16_t add_index);
int Overlay_z_cmp(void *a, void *b);

#endif
#ifndef __overlay_bindings_h
#define __overlay_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Overlay_lib;
extern const char *luab_Overlay_metatable;
typedef Scripting_userdata_for(Overlay) Overlay_userdata;
Scripting_caster_for(Overlay, luaL_tooverlay);

int luaopen_dabes_overlay(lua_State *L);


#endif
#ifndef __shape_matcher_bindings_h
#define __shape_matcher_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Shape_lib;
extern const char *luab_Shape_metatable;
typedef Scripting_userdata_for(Shape) Shape_userdata;
Scripting_caster_for(Shape, luaL_toshape);

extern const char *luab_ShapeMatcher_lib;
extern const char *luab_ShapeMatcher_metatable;
typedef Scripting_userdata_for(ShapeMatcher) ShapeMatcher_userdata;
Scripting_caster_for(ShapeMatcher, luaL_toshapematcher);

int luaopen_dabes_shape_matcher(lua_State *L);

#endif
#ifndef __vpolygon_h
#define __vpolygon_h

typedef struct VPolygon {
    VPoint origin;
    int num_points;
    VPoint points[];
} VPolygon;

VPolygon *VPolygon_create(int num_points, VPoint *points);
VPolygon *VPolygon_from_rect(VRect rect);
void VPolygon_destroy(VPolygon *poly);
void VPolygon_set_point(VPolygon *poly, int i, VPoint point);
VPoint VPolygon_get_point(VPolygon *poly, int i);
void VPolygon_wind(VPolygon *poly, short int clockwise);
int VPolygon_is_clockwise(VPolygon *poly);

#endif
#ifndef __chipmunk_recorder_h
#define __chipmunk_recorder_h
#include <chipmunk/chipmunk.h>

typedef struct ChipmunkRecorderFrame {
    short int keyframe;

    short int has_delta_pos;
    VPoint pos;

    short int has_delta_velo;
    VPoint velo;

    short int has_sprite_frame;
    int sprite_frame;

    short int has_sprite_direction;
    SpriteDirection sprite_direction;
} ChipmunkRecorderFrame;

typedef struct ChipmunkRecorderCtx {
    int keyframe_every;
    ChipmunkRecorderFrame *prev_frame;
    ChipmunkRecorderFrame tracking_frame;
} ChipmunkRecorderCtx;

extern RecorderProto ChipmunkRecorderProto;

Recorder *ChipmunkRecorder_create(int preroll_ms, int fps);
int ChipmunkRecorder_contextualize(Recorder *recorder);

#endif
#ifndef __recorder_bindings_h
#define __recorder_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Recorder_lib;
extern const char *luab_Recorder_metatable;

typedef Scripting_userdata_for(Recorder) Recorder_userdata;

Scripting_caster_for(Recorder, luaL_torecorder);

int luaopen_dabes_recorder(lua_State *L);

#endif
#ifndef __chipmunk_scene_h
#define __chipmunk_scene_h

#define COLLISION_SLOP 0.1

typedef struct {
    Scene *scene;
    Engine *engine;
} OCSIterData;

typedef enum {
  OCSCollisionTypeEntity = 1,
  OCSCollisionTypeTile = 2,
  OCSCollisionTypeDrawShape = 3,
  OCSCollisionTypeSensor = 4,
  OCSCollisionTypeStaticEntity = 5
} OCSCollisionType;

extern SceneProto ChipmunkSceneProto;

#endif
#ifndef __scene_bindings_h
#define __scene_bindings_h
#include <lua/lua.h>
#include <lua/lualib.h>
#include <lua/lauxlib.h>

extern const char *luab_Scene_lib;
extern const char *luab_Scene_metatable;

typedef Scripting_userdata_for(Scene) Scene_userdata;

Scripting_caster_for(Scene, luaL_toscene);

int luaopen_dabes_scene(lua_State *L);
Scene *luaL_get_current_scene(lua_State *L);
int luaL_flip_scene(lua_State *L);

#endif
#ifndef __static_scene_h
#define __static_scene_h

extern SceneProto StaticSceneProto;

#endif
#ifndef __telemetry_splash_scene_h
#define __telemetry_splash_scene_h

extern SceneProto TelemetrySplashSceneProto;

#endif
